{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Dvc Task","text":"<ul> <li>API Reference</li> </ul>"},{"location":"reference/dvc_task/","title":"Dvc task","text":"<p>DVC Task.</p>"},{"location":"reference/dvc_task/exceptions/","title":"Exceptions","text":"<p>Exception classes.</p>"},{"location":"reference/dvc_task/exceptions/#dvc_task.exceptions.DvcTaskError","title":"<code>DvcTaskError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base DVC Task exception.</p> Source code in <code>dvc_task/exceptions.py</code> <pre><code>class DvcTaskError(Exception):\n    \"\"\"Base DVC Task exception.\"\"\"\n</code></pre>"},{"location":"reference/dvc_task/utils/","title":"Utils","text":"<p>General utilities.</p>"},{"location":"reference/dvc_task/utils/#dvc_task.utils.makedirs","title":"<code>makedirs(path, exist_ok=False, mode=None)</code>","text":"<p>Make the specified directory and any parent directories.</p> Source code in <code>dvc_task/utils.py</code> <pre><code>def makedirs(path: str, exist_ok: bool = False, mode: Optional[int] = None):\n    \"\"\"Make the specified directory and any parent directories.\"\"\"\n    if mode is None:\n        os.makedirs(path, exist_ok=exist_ok)\n        return\n\n    # Modified version of os.makedirs() with support for extended mode\n    # (e.g. S_ISGID)\n    head, tail = os.path.split(path)\n    if not tail:\n        head, tail = os.path.split(head)\n    if head and tail and not os.path.exists(head):\n        try:\n            makedirs(head, exist_ok=exist_ok, mode=mode)\n        except FileExistsError:\n            # Defeats race condition when another thread created the path\n            pass\n        cdir = os.curdir\n        if tail == cdir:  # foo/newdir/. exists if foo/newdir exists\n            return\n    try:\n        os.mkdir(path, mode)\n    except OSError:\n        # Cannot rely on checking for EEXIST, since the operating system\n        # could give priority to other errors like EACCES or EROFS\n        if not exist_ok or not os.path.isdir(path):\n            raise\n\n    try:\n        os.chmod(path, mode)\n    except OSError:\n        logger.debug(\"failed to chmod '%o' '%s'\", mode, path, exc_info=True)\n</code></pre>"},{"location":"reference/dvc_task/utils/#dvc_task.utils.remove","title":"<code>remove(path)</code>","text":"<p>Remove the specified path.</p> Source code in <code>dvc_task/utils.py</code> <pre><code>def remove(path: str):\n    \"\"\"Remove the specified path.\"\"\"\n    logger.debug(\"Removing '%s'\", path)\n    try:\n        if os.path.isdir(path):\n            shutil.rmtree(path, onerror=_chmod)\n        else:\n            _unlink(path, _chmod)\n    except OSError as exc:\n        if exc.errno != errno.ENOENT:\n            raise\n</code></pre>"},{"location":"reference/dvc_task/utils/#dvc_task.utils.unc_path","title":"<code>unc_path(path)</code>","text":"<p>Return UNC formatted path.</p> <p>Returns the unmodified path on posix platforms.</p> Source code in <code>dvc_task/utils.py</code> <pre><code>def unc_path(path: str) -&gt; str:\n    \"\"\"Return UNC formatted path.\n\n    Returns the unmodified path on posix platforms.\n    \"\"\"\n    # Celery/Kombu URLs only take absolute filesystem paths\n    # (UNC paths on windows)\n    path = os.path.abspath(path)\n    if os.name != \"nt\":\n        return path\n    drive, tail = os.path.splitdrive(path)\n    if drive.endswith(\":\"):\n        return f\"\\\\\\\\?\\\\{drive}{tail}\"\n    return f\"{drive}{tail}\"\n</code></pre>"},{"location":"reference/dvc_task/app/","title":"App","text":"<p>DVC Task app factories.</p>"},{"location":"reference/dvc_task/app/#dvc_task.app.FSApp","title":"<code>FSApp</code>","text":"<p>               Bases: <code>Celery</code></p> <p>Local filesystem-based Celery application.</p> <p>Uses Kombu filesystem:// broker and results backend</p> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>class FSApp(Celery):\n    \"\"\"Local filesystem-based Celery application.\n\n    Uses Kombu filesystem:// broker and results backend\n    \"\"\"\n\n    def __init__(\n        self,\n        *args,\n        wdir: Optional[str] = None,\n        mkdir: bool = False,\n        task_serializer: str = \"json\",\n        result_serializer: str = \"json\",\n        **kwargs: Any,\n    ):\n        \"\"\"Construct an FSApp.\n\n        Arguments:\n            wdir: App broker/results directory. Defaults to current working\n                directory.\n            mkdir: Create broker/results subdirectories if they do not already\n                exist.\n            task_serializer: Default task serializer.\n            result_serializer: Default result serializer.\n\n        Additional arguments will be passed into the Celery constructor.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.wdir = wdir or os.getcwd()\n        self.conf.update(\n            _get_fs_config(\n                self.wdir,\n                mkdir=mkdir,\n                task_serializer=task_serializer,\n                result_serializer=result_serializer,\n            )\n        )\n        logger.debug(\"Initialized filesystem:// app in '%s'\", wdir)\n        self._processed_msg_path_cache: Dict[str, str] = {}\n        self._queued_msg_path_cache: Dict[str, str] = {}\n\n    def __reduce_keys__(self) -&gt; Dict[str, Any]:\n        keys = super().__reduce_keys__()  # type: ignore[misc]\n        keys.update({\"wdir\": self.wdir})\n        return keys\n\n    def _iter_folder(\n        self,\n        folder_name: str,\n        path_cache: Dict[str, str],\n        queue: Optional[str] = None,\n    ) -&gt; Iterator[Message]:\n        \"\"\"Iterate over queued tasks inside a folder\n\n        Arguments:\n            folder_name: the folder to iterate\n            path_cache: cache of message path.\n            queue: Optional name of queue.\n        \"\"\"\n        with self.connection_for_read() as conn:  # type: ignore[attr-defined]\n            with conn.channel() as channel:  # type: ignore[attr-defined]\n                folder = getattr(channel, folder_name)\n                for filename in sorted(os.listdir(folder)):\n                    path = os.path.join(folder, filename)\n                    try:\n                        with open(path, \"rb\") as fobj:\n                            lock(fobj, LOCK_SH)\n                            try:\n                                payload = fobj.read()\n                            finally:\n                                unlock(fobj)\n                    except FileNotFoundError:\n                        # Messages returned by `listdir` call may have been\n                        # acknowledged and moved to `processed_folder` by the\n                        # time we try to read them here\n                        continue\n                    if not payload:\n                        continue\n                    msg = channel.Message(loads(bytes_to_str(payload)), channel=channel)\n                    path_cache[msg.delivery_tag] = path\n                    if queue is None:\n                        yield msg\n                    else:\n                        delivery_info = msg.properties.get(\"delivery_info\", {})\n                        if delivery_info.get(\"routing_key\") == queue:\n                            yield msg\n\n    def _iter_data_folder(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n        yield from self._iter_folder(\n            \"data_folder_in\", self._queued_msg_path_cache, queue=queue\n        )\n\n    def _iter_processed_folder(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n        yield from self._iter_folder(\n            \"processed_folder\", self._processed_msg_path_cache, queue=queue\n        )\n\n    def iter_queued(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n        \"\"\"Iterate over queued tasks which have not been taken by a worker.\n\n        Arguments:\n            queue: Optional name of queue.\n        \"\"\"\n        queue = queue or self.conf.task_default_queue\n        yield from self._iter_data_folder(queue=queue)\n\n    def iter_processed(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n        \"\"\"Iterate over tasks which have been taken by a worker.\n\n        Arguments:\n            queue: Optional name of queue.\n        \"\"\"\n        queue = queue or self.conf.task_default_queue\n        yield from self._iter_processed_folder(queue=queue)\n\n    @staticmethod\n    def _delete_msg(\n        delivery_tag: str,\n        msg_collection: Iterable[Message],\n        path_cache: Dict[str, str],\n    ):\n        \"\"\"delete the specified message.\n\n        Arguments:\n            delivery_tag: delivery tag of the message to be deleted.\n            msg_collection: where to found this message.\n            path_cache: cache of message path.\n\n        Raises:\n            ValueError: Invalid delivery_tag\n        \"\"\"\n        path = path_cache.get(delivery_tag)\n        if path and os.path.exists(path):\n            remove(path)\n            del path_cache[delivery_tag]\n            return\n\n        for msg in msg_collection:\n            if msg.delivery_tag == delivery_tag:\n                remove(path_cache[delivery_tag])\n                del path_cache[delivery_tag]\n                return\n        raise ValueError(f\"Message '{delivery_tag}' not found\")\n\n    def reject(self, delivery_tag: str):\n        \"\"\"Reject the specified message.\n\n        Allows the caller to reject FS broker messages without establishing a\n        full Kombu consumer. Requeue is not supported.\n\n        Raises:\n            ValueError: Invalid delivery_tag\n        \"\"\"\n        self._delete_msg(delivery_tag, self.iter_queued(), self._queued_msg_path_cache)\n\n    def purge(self, delivery_tag: str):\n        \"\"\"Purge the specified processed message.\n\n        Allows the caller to purge completed FS broker messages without\n        establishing a full Kombu consumer. Requeue is not supported.\n\n        Raises:\n            ValueError: Invalid delivery_tag\n        \"\"\"\n        self._delete_msg(\n            delivery_tag, self.iter_processed(), self._processed_msg_path_cache\n        )\n\n    def _gc(self, exclude: Optional[List[str]] = None):\n        \"\"\"Garbage collect expired FS broker messages.\n\n        Arguments:\n            exclude: Exclude (do not garbage collect) messages from the specified\n                queues.\n        \"\"\"\n\n        def _delete_expired(\n            msg: Message,\n            queues: Set[str],\n            now: float,\n            cache: Dict[str, str],\n            include_tickets: bool = False,\n        ):\n            assert isinstance(msg.properties, dict)\n            properties = cast(Dict[str, Any], msg.properties)\n            delivery_info: Dict[str, str] = properties.get(\"delivery_info\", {})\n            if queues:\n                routing_key = delivery_info.get(\"routing_key\")\n                if routing_key and routing_key in queues:\n                    return\n            headers = cast(Dict[str, Any], msg.headers)\n            expires: Optional[float] = headers.get(\"expires\")\n            ticket = msg.headers.get(\"ticket\")\n            if include_tickets and ticket or (expires is not None and expires &lt;= now):\n                assert msg.delivery_tag\n                try:\n                    self._delete_msg(msg.delivery_tag, [], cache)\n                except ValueError:\n                    pass\n\n        queues = set(exclude) if exclude else set()\n        now = datetime.now().timestamp()  # noqa: DTZ005\n        for msg in self._iter_data_folder():\n            _delete_expired(msg, queues, now, self._queued_msg_path_cache)\n        for msg in self._iter_processed_folder():\n            _delete_expired(\n                msg, queues, now, self._processed_msg_path_cache, include_tickets=True\n            )\n\n    def clean(self):\n        \"\"\"Clean extraneous celery messages from this FSApp.\"\"\"\n        self._gc(exclude=[self.conf.task_default_queue])\n        self._clean_pidbox(f\"reply.{self.conf.task_default_queue}.pidbox\")\n\n    def _clean_pidbox(self, exchange: str):\n        \"\"\"Clean pidbox replies for the specified exchange.\"\"\"\n\n        def _delete_replies(msg: Message, exchange: str, cache: Dict[str, str]):\n            assert isinstance(msg.properties, dict)\n            properties = cast(Dict[str, Any], msg.properties)\n            delivery_info: Dict[str, str] = properties.get(\"delivery_info\", {})\n            if delivery_info.get(\"exchange\", \"\") == exchange:\n                assert msg.delivery_tag\n                try:\n                    self._delete_msg(msg.delivery_tag, [], cache)\n                except ValueError:\n                    pass\n\n        for msg in self._iter_data_folder():\n            _delete_replies(msg, exchange, self._queued_msg_path_cache)\n</code></pre>"},{"location":"reference/dvc_task/app/#dvc_task.app.FSApp.__init__","title":"<code>__init__(*args, wdir=None, mkdir=False, task_serializer='json', result_serializer='json', **kwargs)</code>","text":"<p>Construct an FSApp.</p> <p>Parameters:</p> Name Type Description Default <code>wdir</code> <code>Optional[str]</code> <p>App broker/results directory. Defaults to current working directory.</p> <code>None</code> <code>mkdir</code> <code>bool</code> <p>Create broker/results subdirectories if they do not already exist.</p> <code>False</code> <code>task_serializer</code> <code>str</code> <p>Default task serializer.</p> <code>'json'</code> <code>result_serializer</code> <code>str</code> <p>Default result serializer.</p> <code>'json'</code> <p>Additional arguments will be passed into the Celery constructor.</p> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    wdir: Optional[str] = None,\n    mkdir: bool = False,\n    task_serializer: str = \"json\",\n    result_serializer: str = \"json\",\n    **kwargs: Any,\n):\n    \"\"\"Construct an FSApp.\n\n    Arguments:\n        wdir: App broker/results directory. Defaults to current working\n            directory.\n        mkdir: Create broker/results subdirectories if they do not already\n            exist.\n        task_serializer: Default task serializer.\n        result_serializer: Default result serializer.\n\n    Additional arguments will be passed into the Celery constructor.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.wdir = wdir or os.getcwd()\n    self.conf.update(\n        _get_fs_config(\n            self.wdir,\n            mkdir=mkdir,\n            task_serializer=task_serializer,\n            result_serializer=result_serializer,\n        )\n    )\n    logger.debug(\"Initialized filesystem:// app in '%s'\", wdir)\n    self._processed_msg_path_cache: Dict[str, str] = {}\n    self._queued_msg_path_cache: Dict[str, str] = {}\n</code></pre>"},{"location":"reference/dvc_task/app/#dvc_task.app.FSApp.clean","title":"<code>clean()</code>","text":"<p>Clean extraneous celery messages from this FSApp.</p> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def clean(self):\n    \"\"\"Clean extraneous celery messages from this FSApp.\"\"\"\n    self._gc(exclude=[self.conf.task_default_queue])\n    self._clean_pidbox(f\"reply.{self.conf.task_default_queue}.pidbox\")\n</code></pre>"},{"location":"reference/dvc_task/app/#dvc_task.app.FSApp.iter_processed","title":"<code>iter_processed(queue=None)</code>","text":"<p>Iterate over tasks which have been taken by a worker.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Optional[str]</code> <p>Optional name of queue.</p> <code>None</code> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def iter_processed(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n    \"\"\"Iterate over tasks which have been taken by a worker.\n\n    Arguments:\n        queue: Optional name of queue.\n    \"\"\"\n    queue = queue or self.conf.task_default_queue\n    yield from self._iter_processed_folder(queue=queue)\n</code></pre>"},{"location":"reference/dvc_task/app/#dvc_task.app.FSApp.iter_queued","title":"<code>iter_queued(queue=None)</code>","text":"<p>Iterate over queued tasks which have not been taken by a worker.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Optional[str]</code> <p>Optional name of queue.</p> <code>None</code> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def iter_queued(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n    \"\"\"Iterate over queued tasks which have not been taken by a worker.\n\n    Arguments:\n        queue: Optional name of queue.\n    \"\"\"\n    queue = queue or self.conf.task_default_queue\n    yield from self._iter_data_folder(queue=queue)\n</code></pre>"},{"location":"reference/dvc_task/app/#dvc_task.app.FSApp.purge","title":"<code>purge(delivery_tag)</code>","text":"<p>Purge the specified processed message.</p> <p>Allows the caller to purge completed FS broker messages without establishing a full Kombu consumer. Requeue is not supported.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid delivery_tag</p> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def purge(self, delivery_tag: str):\n    \"\"\"Purge the specified processed message.\n\n    Allows the caller to purge completed FS broker messages without\n    establishing a full Kombu consumer. Requeue is not supported.\n\n    Raises:\n        ValueError: Invalid delivery_tag\n    \"\"\"\n    self._delete_msg(\n        delivery_tag, self.iter_processed(), self._processed_msg_path_cache\n    )\n</code></pre>"},{"location":"reference/dvc_task/app/#dvc_task.app.FSApp.reject","title":"<code>reject(delivery_tag)</code>","text":"<p>Reject the specified message.</p> <p>Allows the caller to reject FS broker messages without establishing a full Kombu consumer. Requeue is not supported.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid delivery_tag</p> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def reject(self, delivery_tag: str):\n    \"\"\"Reject the specified message.\n\n    Allows the caller to reject FS broker messages without establishing a\n    full Kombu consumer. Requeue is not supported.\n\n    Raises:\n        ValueError: Invalid delivery_tag\n    \"\"\"\n    self._delete_msg(delivery_tag, self.iter_queued(), self._queued_msg_path_cache)\n</code></pre>"},{"location":"reference/dvc_task/app/filesystem/","title":"Filesystem","text":"<p>(Local) filesystem based Celery application.</p>"},{"location":"reference/dvc_task/app/filesystem/#dvc_task.app.filesystem.FSApp","title":"<code>FSApp</code>","text":"<p>               Bases: <code>Celery</code></p> <p>Local filesystem-based Celery application.</p> <p>Uses Kombu filesystem:// broker and results backend</p> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>class FSApp(Celery):\n    \"\"\"Local filesystem-based Celery application.\n\n    Uses Kombu filesystem:// broker and results backend\n    \"\"\"\n\n    def __init__(\n        self,\n        *args,\n        wdir: Optional[str] = None,\n        mkdir: bool = False,\n        task_serializer: str = \"json\",\n        result_serializer: str = \"json\",\n        **kwargs: Any,\n    ):\n        \"\"\"Construct an FSApp.\n\n        Arguments:\n            wdir: App broker/results directory. Defaults to current working\n                directory.\n            mkdir: Create broker/results subdirectories if they do not already\n                exist.\n            task_serializer: Default task serializer.\n            result_serializer: Default result serializer.\n\n        Additional arguments will be passed into the Celery constructor.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.wdir = wdir or os.getcwd()\n        self.conf.update(\n            _get_fs_config(\n                self.wdir,\n                mkdir=mkdir,\n                task_serializer=task_serializer,\n                result_serializer=result_serializer,\n            )\n        )\n        logger.debug(\"Initialized filesystem:// app in '%s'\", wdir)\n        self._processed_msg_path_cache: Dict[str, str] = {}\n        self._queued_msg_path_cache: Dict[str, str] = {}\n\n    def __reduce_keys__(self) -&gt; Dict[str, Any]:\n        keys = super().__reduce_keys__()  # type: ignore[misc]\n        keys.update({\"wdir\": self.wdir})\n        return keys\n\n    def _iter_folder(\n        self,\n        folder_name: str,\n        path_cache: Dict[str, str],\n        queue: Optional[str] = None,\n    ) -&gt; Iterator[Message]:\n        \"\"\"Iterate over queued tasks inside a folder\n\n        Arguments:\n            folder_name: the folder to iterate\n            path_cache: cache of message path.\n            queue: Optional name of queue.\n        \"\"\"\n        with self.connection_for_read() as conn:  # type: ignore[attr-defined]\n            with conn.channel() as channel:  # type: ignore[attr-defined]\n                folder = getattr(channel, folder_name)\n                for filename in sorted(os.listdir(folder)):\n                    path = os.path.join(folder, filename)\n                    try:\n                        with open(path, \"rb\") as fobj:\n                            lock(fobj, LOCK_SH)\n                            try:\n                                payload = fobj.read()\n                            finally:\n                                unlock(fobj)\n                    except FileNotFoundError:\n                        # Messages returned by `listdir` call may have been\n                        # acknowledged and moved to `processed_folder` by the\n                        # time we try to read them here\n                        continue\n                    if not payload:\n                        continue\n                    msg = channel.Message(loads(bytes_to_str(payload)), channel=channel)\n                    path_cache[msg.delivery_tag] = path\n                    if queue is None:\n                        yield msg\n                    else:\n                        delivery_info = msg.properties.get(\"delivery_info\", {})\n                        if delivery_info.get(\"routing_key\") == queue:\n                            yield msg\n\n    def _iter_data_folder(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n        yield from self._iter_folder(\n            \"data_folder_in\", self._queued_msg_path_cache, queue=queue\n        )\n\n    def _iter_processed_folder(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n        yield from self._iter_folder(\n            \"processed_folder\", self._processed_msg_path_cache, queue=queue\n        )\n\n    def iter_queued(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n        \"\"\"Iterate over queued tasks which have not been taken by a worker.\n\n        Arguments:\n            queue: Optional name of queue.\n        \"\"\"\n        queue = queue or self.conf.task_default_queue\n        yield from self._iter_data_folder(queue=queue)\n\n    def iter_processed(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n        \"\"\"Iterate over tasks which have been taken by a worker.\n\n        Arguments:\n            queue: Optional name of queue.\n        \"\"\"\n        queue = queue or self.conf.task_default_queue\n        yield from self._iter_processed_folder(queue=queue)\n\n    @staticmethod\n    def _delete_msg(\n        delivery_tag: str,\n        msg_collection: Iterable[Message],\n        path_cache: Dict[str, str],\n    ):\n        \"\"\"delete the specified message.\n\n        Arguments:\n            delivery_tag: delivery tag of the message to be deleted.\n            msg_collection: where to found this message.\n            path_cache: cache of message path.\n\n        Raises:\n            ValueError: Invalid delivery_tag\n        \"\"\"\n        path = path_cache.get(delivery_tag)\n        if path and os.path.exists(path):\n            remove(path)\n            del path_cache[delivery_tag]\n            return\n\n        for msg in msg_collection:\n            if msg.delivery_tag == delivery_tag:\n                remove(path_cache[delivery_tag])\n                del path_cache[delivery_tag]\n                return\n        raise ValueError(f\"Message '{delivery_tag}' not found\")\n\n    def reject(self, delivery_tag: str):\n        \"\"\"Reject the specified message.\n\n        Allows the caller to reject FS broker messages without establishing a\n        full Kombu consumer. Requeue is not supported.\n\n        Raises:\n            ValueError: Invalid delivery_tag\n        \"\"\"\n        self._delete_msg(delivery_tag, self.iter_queued(), self._queued_msg_path_cache)\n\n    def purge(self, delivery_tag: str):\n        \"\"\"Purge the specified processed message.\n\n        Allows the caller to purge completed FS broker messages without\n        establishing a full Kombu consumer. Requeue is not supported.\n\n        Raises:\n            ValueError: Invalid delivery_tag\n        \"\"\"\n        self._delete_msg(\n            delivery_tag, self.iter_processed(), self._processed_msg_path_cache\n        )\n\n    def _gc(self, exclude: Optional[List[str]] = None):\n        \"\"\"Garbage collect expired FS broker messages.\n\n        Arguments:\n            exclude: Exclude (do not garbage collect) messages from the specified\n                queues.\n        \"\"\"\n\n        def _delete_expired(\n            msg: Message,\n            queues: Set[str],\n            now: float,\n            cache: Dict[str, str],\n            include_tickets: bool = False,\n        ):\n            assert isinstance(msg.properties, dict)\n            properties = cast(Dict[str, Any], msg.properties)\n            delivery_info: Dict[str, str] = properties.get(\"delivery_info\", {})\n            if queues:\n                routing_key = delivery_info.get(\"routing_key\")\n                if routing_key and routing_key in queues:\n                    return\n            headers = cast(Dict[str, Any], msg.headers)\n            expires: Optional[float] = headers.get(\"expires\")\n            ticket = msg.headers.get(\"ticket\")\n            if include_tickets and ticket or (expires is not None and expires &lt;= now):\n                assert msg.delivery_tag\n                try:\n                    self._delete_msg(msg.delivery_tag, [], cache)\n                except ValueError:\n                    pass\n\n        queues = set(exclude) if exclude else set()\n        now = datetime.now().timestamp()  # noqa: DTZ005\n        for msg in self._iter_data_folder():\n            _delete_expired(msg, queues, now, self._queued_msg_path_cache)\n        for msg in self._iter_processed_folder():\n            _delete_expired(\n                msg, queues, now, self._processed_msg_path_cache, include_tickets=True\n            )\n\n    def clean(self):\n        \"\"\"Clean extraneous celery messages from this FSApp.\"\"\"\n        self._gc(exclude=[self.conf.task_default_queue])\n        self._clean_pidbox(f\"reply.{self.conf.task_default_queue}.pidbox\")\n\n    def _clean_pidbox(self, exchange: str):\n        \"\"\"Clean pidbox replies for the specified exchange.\"\"\"\n\n        def _delete_replies(msg: Message, exchange: str, cache: Dict[str, str]):\n            assert isinstance(msg.properties, dict)\n            properties = cast(Dict[str, Any], msg.properties)\n            delivery_info: Dict[str, str] = properties.get(\"delivery_info\", {})\n            if delivery_info.get(\"exchange\", \"\") == exchange:\n                assert msg.delivery_tag\n                try:\n                    self._delete_msg(msg.delivery_tag, [], cache)\n                except ValueError:\n                    pass\n\n        for msg in self._iter_data_folder():\n            _delete_replies(msg, exchange, self._queued_msg_path_cache)\n</code></pre>"},{"location":"reference/dvc_task/app/filesystem/#dvc_task.app.filesystem.FSApp.__init__","title":"<code>__init__(*args, wdir=None, mkdir=False, task_serializer='json', result_serializer='json', **kwargs)</code>","text":"<p>Construct an FSApp.</p> <p>Parameters:</p> Name Type Description Default <code>wdir</code> <code>Optional[str]</code> <p>App broker/results directory. Defaults to current working directory.</p> <code>None</code> <code>mkdir</code> <code>bool</code> <p>Create broker/results subdirectories if they do not already exist.</p> <code>False</code> <code>task_serializer</code> <code>str</code> <p>Default task serializer.</p> <code>'json'</code> <code>result_serializer</code> <code>str</code> <p>Default result serializer.</p> <code>'json'</code> <p>Additional arguments will be passed into the Celery constructor.</p> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    wdir: Optional[str] = None,\n    mkdir: bool = False,\n    task_serializer: str = \"json\",\n    result_serializer: str = \"json\",\n    **kwargs: Any,\n):\n    \"\"\"Construct an FSApp.\n\n    Arguments:\n        wdir: App broker/results directory. Defaults to current working\n            directory.\n        mkdir: Create broker/results subdirectories if they do not already\n            exist.\n        task_serializer: Default task serializer.\n        result_serializer: Default result serializer.\n\n    Additional arguments will be passed into the Celery constructor.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.wdir = wdir or os.getcwd()\n    self.conf.update(\n        _get_fs_config(\n            self.wdir,\n            mkdir=mkdir,\n            task_serializer=task_serializer,\n            result_serializer=result_serializer,\n        )\n    )\n    logger.debug(\"Initialized filesystem:// app in '%s'\", wdir)\n    self._processed_msg_path_cache: Dict[str, str] = {}\n    self._queued_msg_path_cache: Dict[str, str] = {}\n</code></pre>"},{"location":"reference/dvc_task/app/filesystem/#dvc_task.app.filesystem.FSApp.clean","title":"<code>clean()</code>","text":"<p>Clean extraneous celery messages from this FSApp.</p> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def clean(self):\n    \"\"\"Clean extraneous celery messages from this FSApp.\"\"\"\n    self._gc(exclude=[self.conf.task_default_queue])\n    self._clean_pidbox(f\"reply.{self.conf.task_default_queue}.pidbox\")\n</code></pre>"},{"location":"reference/dvc_task/app/filesystem/#dvc_task.app.filesystem.FSApp.iter_processed","title":"<code>iter_processed(queue=None)</code>","text":"<p>Iterate over tasks which have been taken by a worker.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Optional[str]</code> <p>Optional name of queue.</p> <code>None</code> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def iter_processed(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n    \"\"\"Iterate over tasks which have been taken by a worker.\n\n    Arguments:\n        queue: Optional name of queue.\n    \"\"\"\n    queue = queue or self.conf.task_default_queue\n    yield from self._iter_processed_folder(queue=queue)\n</code></pre>"},{"location":"reference/dvc_task/app/filesystem/#dvc_task.app.filesystem.FSApp.iter_queued","title":"<code>iter_queued(queue=None)</code>","text":"<p>Iterate over queued tasks which have not been taken by a worker.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Optional[str]</code> <p>Optional name of queue.</p> <code>None</code> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def iter_queued(self, queue: Optional[str] = None) -&gt; Iterator[Message]:\n    \"\"\"Iterate over queued tasks which have not been taken by a worker.\n\n    Arguments:\n        queue: Optional name of queue.\n    \"\"\"\n    queue = queue or self.conf.task_default_queue\n    yield from self._iter_data_folder(queue=queue)\n</code></pre>"},{"location":"reference/dvc_task/app/filesystem/#dvc_task.app.filesystem.FSApp.purge","title":"<code>purge(delivery_tag)</code>","text":"<p>Purge the specified processed message.</p> <p>Allows the caller to purge completed FS broker messages without establishing a full Kombu consumer. Requeue is not supported.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid delivery_tag</p> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def purge(self, delivery_tag: str):\n    \"\"\"Purge the specified processed message.\n\n    Allows the caller to purge completed FS broker messages without\n    establishing a full Kombu consumer. Requeue is not supported.\n\n    Raises:\n        ValueError: Invalid delivery_tag\n    \"\"\"\n    self._delete_msg(\n        delivery_tag, self.iter_processed(), self._processed_msg_path_cache\n    )\n</code></pre>"},{"location":"reference/dvc_task/app/filesystem/#dvc_task.app.filesystem.FSApp.reject","title":"<code>reject(delivery_tag)</code>","text":"<p>Reject the specified message.</p> <p>Allows the caller to reject FS broker messages without establishing a full Kombu consumer. Requeue is not supported.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid delivery_tag</p> Source code in <code>dvc_task/app/filesystem.py</code> <pre><code>def reject(self, delivery_tag: str):\n    \"\"\"Reject the specified message.\n\n    Allows the caller to reject FS broker messages without establishing a\n    full Kombu consumer. Requeue is not supported.\n\n    Raises:\n        ValueError: Invalid delivery_tag\n    \"\"\"\n    self._delete_msg(delivery_tag, self.iter_queued(), self._queued_msg_path_cache)\n</code></pre>"},{"location":"reference/dvc_task/proc/","title":"Proc","text":"<p>Process management module.</p>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ManagedProcess","title":"<code>ManagedProcess</code>","text":"<p>               Bases: <code>AbstractContextManager</code></p> <p>Class to manage the specified process with redirected output.</p> <p>stdout and stderr will both be redirected to .out. Interactive processes (requiring stdin input) are currently unsupported. Source code in <code>dvc_task/proc/process.py</code> <pre><code>class ManagedProcess(AbstractContextManager):\n    \"\"\"Class to manage the specified process with redirected output.\n\n    stdout and stderr will both be redirected to &lt;name&gt;.out.\n    Interactive processes (requiring stdin input) are currently unsupported.\n    \"\"\"\n\n    def __init__(\n        self,\n        args: Union[str, List[str]],\n        env: Optional[Dict[str, str]] = None,\n        wdir: Optional[str] = None,\n        name: Optional[str] = None,\n    ):\n        \"\"\"Construct a MangedProcess.\n\n        Arguments:\n            args: Command to be run.\n            env: Optional environment variables.\n            wdir: If specified, redirected output files will be placed in\n                `wdir`. Defaults to current working directory.\n            name: Name to use for this process, if not specified a UUID will be\n                generated instead.\n        \"\"\"\n        self.args: List[str] = (\n            shlex.split(args, posix=os.name == \"posix\")\n            if isinstance(args, str)\n            else list(args)\n        )\n        self.env = env\n        self.wdir = wdir\n        self.name = name or uuid()\n        self.returncode: Optional[int] = None\n        self._fd_stack = ExitStack()\n        self._proc: Optional[subprocess.Popen] = None\n\n    def __enter__(self):\n        if self._proc is None:\n            self.run()\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        self.wait()\n\n    def _close_fds(self):\n        with self._fd_stack:\n            pass\n\n    def _make_path(self, path: str) -&gt; str:\n        return os.path.join(self.wdir, path) if self.wdir else path\n\n    @cached_property\n    def stdout_path(self) -&gt; str:\n        \"\"\"Return redirected stdout path.\"\"\"\n        return self._make_path(f\"{self.name}.out\")\n\n    @cached_property\n    def info_path(self) -&gt; str:\n        \"\"\"Return process information file path.\"\"\"\n        return self._make_path(f\"{self.name}.json\")\n\n    @cached_property\n    def pidfile_path(self) -&gt; str:\n        \"\"\"Return process pidfile path.\"\"\"\n        return self._make_path(f\"{self.name}.pid\")\n\n    @property\n    def info(self) -&gt; \"ProcessInfo\":\n        \"\"\"Return process information.\"\"\"\n        return ProcessInfo(\n            pid=self.pid,\n            stdin=None,\n            stdout=self.stdout_path,\n            stderr=None,\n            returncode=self.returncode,\n        )\n\n    @property\n    def pid(self) -&gt; int:\n        \"\"\"Return process PID.\n\n        Raises:\n            ValueError: Process is not running.\n        \"\"\"\n        if self._proc is None:\n            raise ValueError\n        return self._proc.pid\n\n    def _make_wdir(self):\n        if self.wdir:\n            makedirs(self.wdir, exist_ok=True)\n\n    def _dump(self):\n        self._make_wdir()\n        self.info.dump(self.info_path)\n\n        with open(self.pidfile_path, \"w\", encoding=\"utf-8\") as fobj:\n            fobj.write(str(self.pid))\n\n    def run(self):\n        \"\"\"Run this process.\"\"\"\n        self._make_wdir()\n        logger.debug(\n            \"Appending output to '%s'\",\n            self.stdout_path,\n        )\n        stdout = self._fd_stack.enter_context(open(self.stdout_path, \"ab\"))  # noqa: SIM115\n        try:\n            self._proc = subprocess.Popen(  # noqa: S603\n                self.args,\n                stdin=subprocess.DEVNULL,\n                stdout=stdout,\n                stderr=subprocess.STDOUT,\n                close_fds=True,\n                shell=False,\n                env=self.env,\n            )\n            self._dump()\n        except Exception:\n            if self._proc is not None:\n                self._proc.kill()\n            self._close_fds()\n            raise\n\n    def wait(self, timeout: Optional[int] = None) -&gt; Optional[int]:\n        \"\"\"Block until a process started with `run` has completed.\n\n        Raises:\n            TimeoutExpired if `timeout` was set and the process\n            did not terminate after `timeout` seconds.\n        \"\"\"\n        if self.returncode is not None or self._proc is None:\n            return self.returncode\n        try:\n            self._proc.wait(timeout=timeout)\n        except subprocess.TimeoutExpired as exc:\n            raise TimeoutExpired(exc.cmd, exc.timeout) from exc\n        except KeyboardInterrupt:\n            pass\n        self.returncode = self._proc.returncode\n        self._close_fds()\n        self._dump()\n        return self.returncode\n\n    @classmethod\n    def spawn(cls, *args, **kwargs) -&gt; Optional[int]:\n        \"\"\"Spawn a ManagedProcess command in the background.\n\n        Returns: The spawned process PID.\n        \"\"\"\n        proc = _DaemonProcess(\n            target=cls._spawn,\n            args=args,\n            kwargs=kwargs,\n            daemon=True,\n        )\n        proc.start()\n        # Do not terminate the child daemon when the main process exits\n        mp.process._children.discard(proc)  # type: ignore[attr-defined]\n        return proc.pid\n\n    @classmethod\n    def _spawn(cls, *args, **kwargs):\n        with cls(*args, **kwargs):\n            pass\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ManagedProcess.info","title":"<code>info: ProcessInfo</code>  <code>property</code>","text":"<p>Return process information.</p>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ManagedProcess.pid","title":"<code>pid: int</code>  <code>property</code>","text":"<p>Return process PID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Process is not running.</p>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ManagedProcess.__init__","title":"<code>__init__(args, env=None, wdir=None, name=None)</code>","text":"<p>Construct a MangedProcess.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Union[str, List[str]]</code> <p>Command to be run.</p> required <code>env</code> <code>Optional[Dict[str, str]]</code> <p>Optional environment variables.</p> <code>None</code> <code>wdir</code> <code>Optional[str]</code> <p>If specified, redirected output files will be placed in <code>wdir</code>. Defaults to current working directory.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Name to use for this process, if not specified a UUID will be generated instead.</p> <code>None</code> Source code in <code>dvc_task/proc/process.py</code> <pre><code>def __init__(\n    self,\n    args: Union[str, List[str]],\n    env: Optional[Dict[str, str]] = None,\n    wdir: Optional[str] = None,\n    name: Optional[str] = None,\n):\n    \"\"\"Construct a MangedProcess.\n\n    Arguments:\n        args: Command to be run.\n        env: Optional environment variables.\n        wdir: If specified, redirected output files will be placed in\n            `wdir`. Defaults to current working directory.\n        name: Name to use for this process, if not specified a UUID will be\n            generated instead.\n    \"\"\"\n    self.args: List[str] = (\n        shlex.split(args, posix=os.name == \"posix\")\n        if isinstance(args, str)\n        else list(args)\n    )\n    self.env = env\n    self.wdir = wdir\n    self.name = name or uuid()\n    self.returncode: Optional[int] = None\n    self._fd_stack = ExitStack()\n    self._proc: Optional[subprocess.Popen] = None\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ManagedProcess.info_path","title":"<code>info_path()</code>","text":"<p>Return process information file path.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@cached_property\ndef info_path(self) -&gt; str:\n    \"\"\"Return process information file path.\"\"\"\n    return self._make_path(f\"{self.name}.json\")\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ManagedProcess.pidfile_path","title":"<code>pidfile_path()</code>","text":"<p>Return process pidfile path.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@cached_property\ndef pidfile_path(self) -&gt; str:\n    \"\"\"Return process pidfile path.\"\"\"\n    return self._make_path(f\"{self.name}.pid\")\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ManagedProcess.run","title":"<code>run()</code>","text":"<p>Run this process.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>def run(self):\n    \"\"\"Run this process.\"\"\"\n    self._make_wdir()\n    logger.debug(\n        \"Appending output to '%s'\",\n        self.stdout_path,\n    )\n    stdout = self._fd_stack.enter_context(open(self.stdout_path, \"ab\"))  # noqa: SIM115\n    try:\n        self._proc = subprocess.Popen(  # noqa: S603\n            self.args,\n            stdin=subprocess.DEVNULL,\n            stdout=stdout,\n            stderr=subprocess.STDOUT,\n            close_fds=True,\n            shell=False,\n            env=self.env,\n        )\n        self._dump()\n    except Exception:\n        if self._proc is not None:\n            self._proc.kill()\n        self._close_fds()\n        raise\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ManagedProcess.spawn","title":"<code>spawn(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Spawn a ManagedProcess command in the background.</p> <p>Returns: The spawned process PID.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@classmethod\ndef spawn(cls, *args, **kwargs) -&gt; Optional[int]:\n    \"\"\"Spawn a ManagedProcess command in the background.\n\n    Returns: The spawned process PID.\n    \"\"\"\n    proc = _DaemonProcess(\n        target=cls._spawn,\n        args=args,\n        kwargs=kwargs,\n        daemon=True,\n    )\n    proc.start()\n    # Do not terminate the child daemon when the main process exits\n    mp.process._children.discard(proc)  # type: ignore[attr-defined]\n    return proc.pid\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ManagedProcess.stdout_path","title":"<code>stdout_path()</code>","text":"<p>Return redirected stdout path.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@cached_property\ndef stdout_path(self) -&gt; str:\n    \"\"\"Return redirected stdout path.\"\"\"\n    return self._make_path(f\"{self.name}.out\")\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ManagedProcess.wait","title":"<code>wait(timeout=None)</code>","text":"<p>Block until a process started with <code>run</code> has completed.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>def wait(self, timeout: Optional[int] = None) -&gt; Optional[int]:\n    \"\"\"Block until a process started with `run` has completed.\n\n    Raises:\n        TimeoutExpired if `timeout` was set and the process\n        did not terminate after `timeout` seconds.\n    \"\"\"\n    if self.returncode is not None or self._proc is None:\n        return self.returncode\n    try:\n        self._proc.wait(timeout=timeout)\n    except subprocess.TimeoutExpired as exc:\n        raise TimeoutExpired(exc.cmd, exc.timeout) from exc\n    except KeyboardInterrupt:\n        pass\n    self.returncode = self._proc.returncode\n    self._close_fds()\n    self._dump()\n    return self.returncode\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessInfo","title":"<code>ProcessInfo</code>  <code>dataclass</code>","text":"<p>Process information.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@dataclass\nclass ProcessInfo:\n    \"\"\"Process information.\"\"\"\n\n    pid: int\n    stdin: Optional[str]\n    stdout: Optional[str]\n    stderr: Optional[str]\n    returncode: Optional[int]\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"ProcessInfo\":\n        \"\"\"Construct ProcessInfo from the specified dictionary.\"\"\"\n        return cls(**data)\n\n    @classmethod\n    def load(cls, filename: str) -&gt; \"ProcessInfo\":\n        \"\"\"Construct the process information from a file.\"\"\"\n        with open(filename, encoding=\"utf-8\") as fobj:\n            return cls.from_dict(json.load(fobj))\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Return this info as a dictionary.\"\"\"\n        return asdict(self)\n\n    def dump(self, filename: str) -&gt; None:\n        \"\"\"Dump the process information into a file.\"\"\"\n        directory, file = os.path.split(filename)\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\",\n            encoding=\"utf-8\",\n            dir=directory,\n            prefix=f\"{file}.\",\n            suffix=\".tmp\",\n            delete=False,\n        ) as tmp:\n            json.dump(self.asdict(), tmp)\n        os.replace(tmp.name, filename)\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessInfo.asdict","title":"<code>asdict()</code>","text":"<p>Return this info as a dictionary.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Return this info as a dictionary.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessInfo.dump","title":"<code>dump(filename)</code>","text":"<p>Dump the process information into a file.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>def dump(self, filename: str) -&gt; None:\n    \"\"\"Dump the process information into a file.\"\"\"\n    directory, file = os.path.split(filename)\n    with tempfile.NamedTemporaryFile(\n        mode=\"w\",\n        encoding=\"utf-8\",\n        dir=directory,\n        prefix=f\"{file}.\",\n        suffix=\".tmp\",\n        delete=False,\n    ) as tmp:\n        json.dump(self.asdict(), tmp)\n    os.replace(tmp.name, filename)\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessInfo.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Construct ProcessInfo from the specified dictionary.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"ProcessInfo\":\n    \"\"\"Construct ProcessInfo from the specified dictionary.\"\"\"\n    return cls(**data)\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessInfo.load","title":"<code>load(filename)</code>  <code>classmethod</code>","text":"<p>Construct the process information from a file.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@classmethod\ndef load(cls, filename: str) -&gt; \"ProcessInfo\":\n    \"\"\"Construct the process information from a file.\"\"\"\n    with open(filename, encoding=\"utf-8\") as fobj:\n        return cls.from_dict(json.load(fobj))\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager","title":"<code>ProcessManager</code>","text":"<p>Manager for controlling background ManagedProcess(es) via celery.</p> <p>Spawned process entries are kept in the manager directory until they are explicitly removed (with remove() or cleanup()) so that return value and log information can be accessed after a process has completed.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>class ProcessManager:\n    \"\"\"Manager for controlling background ManagedProcess(es) via celery.\n\n    Spawned process entries are kept in the manager directory until they\n    are explicitly removed (with remove() or cleanup()) so that return\n    value and log information can be accessed after a process has completed.\n    \"\"\"\n\n    def __init__(\n        self,\n        wdir: Optional[str] = None,\n    ):\n        \"\"\"Construct a ProcessManager\n\n        Arguments:\n            wdir: Directory used for storing process information. Defaults\n                to the current working directory.\n        \"\"\"\n        self.wdir = wdir or os.curdir\n\n    def __iter__(self) -&gt; Generator[str, None, None]:\n        if not os.path.exists(self.wdir):\n            return\n        yield from os.listdir(self.wdir)\n\n    @reraise(FileNotFoundError, KeyError)\n    def __getitem__(self, key: str) -&gt; \"ProcessInfo\":\n        info_path = self._get_info_path(key)\n        return ProcessInfo.load(info_path)\n\n    @reraise(FileNotFoundError, KeyError)\n    def __setitem__(self, key: str, value: \"ProcessInfo\"):\n        info_path = self._get_info_path(key)\n        value.dump(info_path)\n\n    def __delitem__(self, key: str) -&gt; None:\n        path = os.path.join(self.wdir, key)\n        if os.path.exists(path):\n            remove(path)\n\n    def _get_info_path(self, key: str) -&gt; str:\n        return os.path.join(self.wdir, key, f\"{key}.json\")\n\n    def get(self, key: str, default=None) -&gt; \"ProcessInfo\":\n        \"\"\"Return the specified process.\"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def processes(self) -&gt; Generator[Tuple[str, \"ProcessInfo\"], None, None]:\n        \"\"\"Iterate over managed processes.\"\"\"\n        for name in self:\n            try:\n                yield name, self[name]\n            except KeyError:\n                continue\n\n    def run_signature(\n        self,\n        args: Union[str, List[str]],\n        name: Optional[str] = None,\n        task: Optional[str] = None,\n        env: Optional[Dict[str, str]] = None,\n        immutable: bool = False,\n    ) -&gt; Signature:\n        \"\"\"Return signature for a task which runs a command in the background.\n\n        Arguments:\n            args: Command to run.\n            name: Optional name to use for the spawned process.\n            task: Optional name of Celery task to use for spawning the process.\n                Defaults to 'dvc_task.proc.tasks.run'.\n            env: Optional environment to be passed into the process.\n            immutable: True if the returned Signature should be immutable.\n\n        Returns:\n            Celery signature for the run task.\n        \"\"\"\n        name = name or uuid()\n        task = task or \"dvc_task.proc.tasks.run\"\n        return signature(\n            task,\n            args=(args,),\n            kwargs={\n                \"name\": name,\n                \"wdir\": os.path.join(self.wdir, name),\n                \"env\": env,\n            },\n            immutable=immutable,\n        )\n\n    def send_signal(self, name: str, sig: int, group: bool = False):  # noqa: C901\n        \"\"\"Send `signal` to the specified named process.\"\"\"\n        try:\n            process_info = self[name]\n        except KeyError as exc:\n            raise ProcessLookupError from exc\n        if sys.platform == \"win32\":\n            if sig not in (\n                signal.SIGTERM,\n                signal.CTRL_C_EVENT,\n                signal.CTRL_BREAK_EVENT,\n            ):\n                raise UnsupportedSignalError(sig)\n\n        def handle_closed_process():\n            logging.warning(\"Process '%s' had already aborted unexpectedly.\", name)\n            process_info.returncode = -1\n            self[name] = process_info\n\n        if process_info.returncode is None:\n            try:\n                if sys.platform != \"win32\" and group:\n                    pgid = os.getpgid(process_info.pid)\n                    os.killpg(pgid, sig)\n                else:\n                    os.kill(process_info.pid, sig)\n            except ProcessLookupError:\n                handle_closed_process()\n                raise\n            except OSError as exc:\n                if sys.platform == \"win32\":\n                    if exc.winerror == 87:\n                        handle_closed_process()\n                        raise ProcessLookupError from exc\n                raise\n        else:\n            raise ProcessLookupError\n\n    def interrupt(self, name: str, group: bool = True):\n        \"\"\"Send interrupt signal to specified named process\"\"\"\n        if sys.platform == \"win32\":\n            self.send_signal(\n                name,\n                signal.CTRL_C_EVENT,\n                group,\n            )\n        else:\n            self.send_signal(name, signal.SIGINT, group)\n\n    def terminate(self, name: str, group: bool = False):\n        \"\"\"Terminate the specified named process.\"\"\"\n        self.send_signal(name, signal.SIGTERM, group)\n\n    def kill(self, name: str, group: bool = False):\n        \"\"\"Kill the specified named process.\"\"\"\n        if sys.platform == \"win32\":\n            self.send_signal(name, signal.SIGTERM, group)\n        else:\n            self.send_signal(name, signal.SIGKILL, group)\n\n    def remove(self, name: str, force: bool = False):\n        \"\"\"Remove the specified named process from this manager.\n\n        If the specified process is still running, it will be forcefully killed\n        if `force` is True`, otherwise an exception will be raised.\n\n        Raises:\n            ProcessNotTerminatedError if the specified process is still\n            running and was not forcefully killed.\n        \"\"\"\n        try:\n            process_info = self[name]\n        except KeyError:\n            return\n        if process_info.returncode is None and not force:\n            raise ProcessNotTerminatedError(name)\n        try:\n            self.kill(name)\n        except ProcessLookupError:\n            pass\n        del self[name]\n\n    def cleanup(self, force: bool = False):\n        \"\"\"Remove stale (terminated) processes from this manager.\"\"\"\n        for name in self:\n            try:\n                self.remove(name, force)\n            except ProcessNotTerminatedError:\n                continue\n\n    def follow(\n        self,\n        name: str,\n        encoding: Optional[str] = None,\n        sleep_interval: int = 1,\n    ) -&gt; Generator[str, None, None]:\n        \"\"\"Iterate over lines in redirected output for a process.\n\n        This will block calling thread when waiting for output (until the\n        followed process has exited).\n\n        Arguments:\n            name: Process name.\n            encoding: Text encoding for redirected output. Defaults to\n                `locale.getpreferredencoding()`.\n            sleep_interval: Sleep interval for follow iterations (when waiting\n                for output).\n\n        Note:\n            Yielded strings may not always end in line terminators (all\n            available output will yielded if EOF is reached).\n        \"\"\"\n        output_path = self[name].stdout\n        if output_path is None:\n            return\n        with open(\n            output_path,\n            encoding=encoding or locale.getpreferredencoding(),\n        ) as fobj:\n            while True:\n                offset = fobj.tell()\n                line = fobj.readline()\n                if line:\n                    yield line\n                else:\n                    info = self[name]\n                    if info.returncode is not None:\n                        return\n                    time.sleep(sleep_interval)\n                    fobj.seek(offset)\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager.__init__","title":"<code>__init__(wdir=None)</code>","text":"<p>Construct a ProcessManager</p> <p>Parameters:</p> Name Type Description Default <code>wdir</code> <code>Optional[str]</code> <p>Directory used for storing process information. Defaults to the current working directory.</p> <code>None</code> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def __init__(\n    self,\n    wdir: Optional[str] = None,\n):\n    \"\"\"Construct a ProcessManager\n\n    Arguments:\n        wdir: Directory used for storing process information. Defaults\n            to the current working directory.\n    \"\"\"\n    self.wdir = wdir or os.curdir\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager.cleanup","title":"<code>cleanup(force=False)</code>","text":"<p>Remove stale (terminated) processes from this manager.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def cleanup(self, force: bool = False):\n    \"\"\"Remove stale (terminated) processes from this manager.\"\"\"\n    for name in self:\n        try:\n            self.remove(name, force)\n        except ProcessNotTerminatedError:\n            continue\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager.follow","title":"<code>follow(name, encoding=None, sleep_interval=1)</code>","text":"<p>Iterate over lines in redirected output for a process.</p> <p>This will block calling thread when waiting for output (until the followed process has exited).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Process name.</p> required <code>encoding</code> <code>Optional[str]</code> <p>Text encoding for redirected output. Defaults to <code>locale.getpreferredencoding()</code>.</p> <code>None</code> <code>sleep_interval</code> <code>int</code> <p>Sleep interval for follow iterations (when waiting for output).</p> <code>1</code> Note <p>Yielded strings may not always end in line terminators (all available output will yielded if EOF is reached).</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def follow(\n    self,\n    name: str,\n    encoding: Optional[str] = None,\n    sleep_interval: int = 1,\n) -&gt; Generator[str, None, None]:\n    \"\"\"Iterate over lines in redirected output for a process.\n\n    This will block calling thread when waiting for output (until the\n    followed process has exited).\n\n    Arguments:\n        name: Process name.\n        encoding: Text encoding for redirected output. Defaults to\n            `locale.getpreferredencoding()`.\n        sleep_interval: Sleep interval for follow iterations (when waiting\n            for output).\n\n    Note:\n        Yielded strings may not always end in line terminators (all\n        available output will yielded if EOF is reached).\n    \"\"\"\n    output_path = self[name].stdout\n    if output_path is None:\n        return\n    with open(\n        output_path,\n        encoding=encoding or locale.getpreferredencoding(),\n    ) as fobj:\n        while True:\n            offset = fobj.tell()\n            line = fobj.readline()\n            if line:\n                yield line\n            else:\n                info = self[name]\n                if info.returncode is not None:\n                    return\n                time.sleep(sleep_interval)\n                fobj.seek(offset)\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager.get","title":"<code>get(key, default=None)</code>","text":"<p>Return the specified process.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def get(self, key: str, default=None) -&gt; \"ProcessInfo\":\n    \"\"\"Return the specified process.\"\"\"\n    try:\n        return self[key]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager.interrupt","title":"<code>interrupt(name, group=True)</code>","text":"<p>Send interrupt signal to specified named process</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def interrupt(self, name: str, group: bool = True):\n    \"\"\"Send interrupt signal to specified named process\"\"\"\n    if sys.platform == \"win32\":\n        self.send_signal(\n            name,\n            signal.CTRL_C_EVENT,\n            group,\n        )\n    else:\n        self.send_signal(name, signal.SIGINT, group)\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager.kill","title":"<code>kill(name, group=False)</code>","text":"<p>Kill the specified named process.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def kill(self, name: str, group: bool = False):\n    \"\"\"Kill the specified named process.\"\"\"\n    if sys.platform == \"win32\":\n        self.send_signal(name, signal.SIGTERM, group)\n    else:\n        self.send_signal(name, signal.SIGKILL, group)\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager.processes","title":"<code>processes()</code>","text":"<p>Iterate over managed processes.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def processes(self) -&gt; Generator[Tuple[str, \"ProcessInfo\"], None, None]:\n    \"\"\"Iterate over managed processes.\"\"\"\n    for name in self:\n        try:\n            yield name, self[name]\n        except KeyError:\n            continue\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager.remove","title":"<code>remove(name, force=False)</code>","text":"<p>Remove the specified named process from this manager.</p> <p>If the specified process is still running, it will be forcefully killed if <code>force</code> is True`, otherwise an exception will be raised.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def remove(self, name: str, force: bool = False):\n    \"\"\"Remove the specified named process from this manager.\n\n    If the specified process is still running, it will be forcefully killed\n    if `force` is True`, otherwise an exception will be raised.\n\n    Raises:\n        ProcessNotTerminatedError if the specified process is still\n        running and was not forcefully killed.\n    \"\"\"\n    try:\n        process_info = self[name]\n    except KeyError:\n        return\n    if process_info.returncode is None and not force:\n        raise ProcessNotTerminatedError(name)\n    try:\n        self.kill(name)\n    except ProcessLookupError:\n        pass\n    del self[name]\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager.run_signature","title":"<code>run_signature(args, name=None, task=None, env=None, immutable=False)</code>","text":"<p>Return signature for a task which runs a command in the background.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Union[str, List[str]]</code> <p>Command to run.</p> required <code>name</code> <code>Optional[str]</code> <p>Optional name to use for the spawned process.</p> <code>None</code> <code>task</code> <code>Optional[str]</code> <p>Optional name of Celery task to use for spawning the process. Defaults to 'dvc_task.proc.tasks.run'.</p> <code>None</code> <code>env</code> <code>Optional[Dict[str, str]]</code> <p>Optional environment to be passed into the process.</p> <code>None</code> <code>immutable</code> <code>bool</code> <p>True if the returned Signature should be immutable.</p> <code>False</code> <p>Returns:</p> Type Description <code>Signature</code> <p>Celery signature for the run task.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def run_signature(\n    self,\n    args: Union[str, List[str]],\n    name: Optional[str] = None,\n    task: Optional[str] = None,\n    env: Optional[Dict[str, str]] = None,\n    immutable: bool = False,\n) -&gt; Signature:\n    \"\"\"Return signature for a task which runs a command in the background.\n\n    Arguments:\n        args: Command to run.\n        name: Optional name to use for the spawned process.\n        task: Optional name of Celery task to use for spawning the process.\n            Defaults to 'dvc_task.proc.tasks.run'.\n        env: Optional environment to be passed into the process.\n        immutable: True if the returned Signature should be immutable.\n\n    Returns:\n        Celery signature for the run task.\n    \"\"\"\n    name = name or uuid()\n    task = task or \"dvc_task.proc.tasks.run\"\n    return signature(\n        task,\n        args=(args,),\n        kwargs={\n            \"name\": name,\n            \"wdir\": os.path.join(self.wdir, name),\n            \"env\": env,\n        },\n        immutable=immutable,\n    )\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager.send_signal","title":"<code>send_signal(name, sig, group=False)</code>","text":"<p>Send <code>signal</code> to the specified named process.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def send_signal(self, name: str, sig: int, group: bool = False):  # noqa: C901\n    \"\"\"Send `signal` to the specified named process.\"\"\"\n    try:\n        process_info = self[name]\n    except KeyError as exc:\n        raise ProcessLookupError from exc\n    if sys.platform == \"win32\":\n        if sig not in (\n            signal.SIGTERM,\n            signal.CTRL_C_EVENT,\n            signal.CTRL_BREAK_EVENT,\n        ):\n            raise UnsupportedSignalError(sig)\n\n    def handle_closed_process():\n        logging.warning(\"Process '%s' had already aborted unexpectedly.\", name)\n        process_info.returncode = -1\n        self[name] = process_info\n\n    if process_info.returncode is None:\n        try:\n            if sys.platform != \"win32\" and group:\n                pgid = os.getpgid(process_info.pid)\n                os.killpg(pgid, sig)\n            else:\n                os.kill(process_info.pid, sig)\n        except ProcessLookupError:\n            handle_closed_process()\n            raise\n        except OSError as exc:\n            if sys.platform == \"win32\":\n                if exc.winerror == 87:\n                    handle_closed_process()\n                    raise ProcessLookupError from exc\n            raise\n    else:\n        raise ProcessLookupError\n</code></pre>"},{"location":"reference/dvc_task/proc/#dvc_task.proc.ProcessManager.terminate","title":"<code>terminate(name, group=False)</code>","text":"<p>Terminate the specified named process.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def terminate(self, name: str, group: bool = False):\n    \"\"\"Terminate the specified named process.\"\"\"\n    self.send_signal(name, signal.SIGTERM, group)\n</code></pre>"},{"location":"reference/dvc_task/proc/exceptions/","title":"Exceptions","text":"<p>Process exceptions.</p>"},{"location":"reference/dvc_task/proc/exceptions/#dvc_task.proc.exceptions.ProcessNotFoundError","title":"<code>ProcessNotFoundError</code>","text":"<p>               Bases: <code>DvcTaskError</code></p> <p>Process does not exist.</p> Source code in <code>dvc_task/proc/exceptions.py</code> <pre><code>class ProcessNotFoundError(DvcTaskError):\n    \"\"\"Process does not exist.\"\"\"\n\n    def __init__(self, name):\n        super().__init__(f\"Managed process '{name}' does not exist.\")\n</code></pre>"},{"location":"reference/dvc_task/proc/exceptions/#dvc_task.proc.exceptions.ProcessNotTerminatedError","title":"<code>ProcessNotTerminatedError</code>","text":"<p>               Bases: <code>DvcTaskError</code></p> <p>Process is still running.</p> Source code in <code>dvc_task/proc/exceptions.py</code> <pre><code>class ProcessNotTerminatedError(DvcTaskError):\n    \"\"\"Process is still running.\"\"\"\n\n    def __init__(self, name):\n        super().__init__(f\"Managed process '{name}' has not been terminated.\")\n</code></pre>"},{"location":"reference/dvc_task/proc/exceptions/#dvc_task.proc.exceptions.TimeoutExpired","title":"<code>TimeoutExpired</code>","text":"<p>               Bases: <code>DvcTaskError</code></p> <p>Process timeout expired.</p> Source code in <code>dvc_task/proc/exceptions.py</code> <pre><code>class TimeoutExpired(DvcTaskError):  # noqa: N818\n    \"\"\"Process timeout expired.\"\"\"\n\n    def __init__(self, cmd, timeout):\n        super().__init__(f\"'{cmd}' did not complete before timeout '{timeout}'\")\n        self.cmd = cmd\n        self.timeout = timeout\n</code></pre>"},{"location":"reference/dvc_task/proc/exceptions/#dvc_task.proc.exceptions.UnsupportedSignalError","title":"<code>UnsupportedSignalError</code>","text":"<p>               Bases: <code>DvcTaskError</code></p> <p>Unsupported process signal.</p> Source code in <code>dvc_task/proc/exceptions.py</code> <pre><code>class UnsupportedSignalError(DvcTaskError):\n    \"\"\"Unsupported process signal.\"\"\"\n\n    def __init__(self, sig):\n        super().__init__(f\"Unsupported signal: {sig}\")\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/","title":"Manager","text":"<p>Serverless process manager.</p>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager","title":"<code>ProcessManager</code>","text":"<p>Manager for controlling background ManagedProcess(es) via celery.</p> <p>Spawned process entries are kept in the manager directory until they are explicitly removed (with remove() or cleanup()) so that return value and log information can be accessed after a process has completed.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>class ProcessManager:\n    \"\"\"Manager for controlling background ManagedProcess(es) via celery.\n\n    Spawned process entries are kept in the manager directory until they\n    are explicitly removed (with remove() or cleanup()) so that return\n    value and log information can be accessed after a process has completed.\n    \"\"\"\n\n    def __init__(\n        self,\n        wdir: Optional[str] = None,\n    ):\n        \"\"\"Construct a ProcessManager\n\n        Arguments:\n            wdir: Directory used for storing process information. Defaults\n                to the current working directory.\n        \"\"\"\n        self.wdir = wdir or os.curdir\n\n    def __iter__(self) -&gt; Generator[str, None, None]:\n        if not os.path.exists(self.wdir):\n            return\n        yield from os.listdir(self.wdir)\n\n    @reraise(FileNotFoundError, KeyError)\n    def __getitem__(self, key: str) -&gt; \"ProcessInfo\":\n        info_path = self._get_info_path(key)\n        return ProcessInfo.load(info_path)\n\n    @reraise(FileNotFoundError, KeyError)\n    def __setitem__(self, key: str, value: \"ProcessInfo\"):\n        info_path = self._get_info_path(key)\n        value.dump(info_path)\n\n    def __delitem__(self, key: str) -&gt; None:\n        path = os.path.join(self.wdir, key)\n        if os.path.exists(path):\n            remove(path)\n\n    def _get_info_path(self, key: str) -&gt; str:\n        return os.path.join(self.wdir, key, f\"{key}.json\")\n\n    def get(self, key: str, default=None) -&gt; \"ProcessInfo\":\n        \"\"\"Return the specified process.\"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def processes(self) -&gt; Generator[Tuple[str, \"ProcessInfo\"], None, None]:\n        \"\"\"Iterate over managed processes.\"\"\"\n        for name in self:\n            try:\n                yield name, self[name]\n            except KeyError:\n                continue\n\n    def run_signature(\n        self,\n        args: Union[str, List[str]],\n        name: Optional[str] = None,\n        task: Optional[str] = None,\n        env: Optional[Dict[str, str]] = None,\n        immutable: bool = False,\n    ) -&gt; Signature:\n        \"\"\"Return signature for a task which runs a command in the background.\n\n        Arguments:\n            args: Command to run.\n            name: Optional name to use for the spawned process.\n            task: Optional name of Celery task to use for spawning the process.\n                Defaults to 'dvc_task.proc.tasks.run'.\n            env: Optional environment to be passed into the process.\n            immutable: True if the returned Signature should be immutable.\n\n        Returns:\n            Celery signature for the run task.\n        \"\"\"\n        name = name or uuid()\n        task = task or \"dvc_task.proc.tasks.run\"\n        return signature(\n            task,\n            args=(args,),\n            kwargs={\n                \"name\": name,\n                \"wdir\": os.path.join(self.wdir, name),\n                \"env\": env,\n            },\n            immutable=immutable,\n        )\n\n    def send_signal(self, name: str, sig: int, group: bool = False):  # noqa: C901\n        \"\"\"Send `signal` to the specified named process.\"\"\"\n        try:\n            process_info = self[name]\n        except KeyError as exc:\n            raise ProcessLookupError from exc\n        if sys.platform == \"win32\":\n            if sig not in (\n                signal.SIGTERM,\n                signal.CTRL_C_EVENT,\n                signal.CTRL_BREAK_EVENT,\n            ):\n                raise UnsupportedSignalError(sig)\n\n        def handle_closed_process():\n            logging.warning(\"Process '%s' had already aborted unexpectedly.\", name)\n            process_info.returncode = -1\n            self[name] = process_info\n\n        if process_info.returncode is None:\n            try:\n                if sys.platform != \"win32\" and group:\n                    pgid = os.getpgid(process_info.pid)\n                    os.killpg(pgid, sig)\n                else:\n                    os.kill(process_info.pid, sig)\n            except ProcessLookupError:\n                handle_closed_process()\n                raise\n            except OSError as exc:\n                if sys.platform == \"win32\":\n                    if exc.winerror == 87:\n                        handle_closed_process()\n                        raise ProcessLookupError from exc\n                raise\n        else:\n            raise ProcessLookupError\n\n    def interrupt(self, name: str, group: bool = True):\n        \"\"\"Send interrupt signal to specified named process\"\"\"\n        if sys.platform == \"win32\":\n            self.send_signal(\n                name,\n                signal.CTRL_C_EVENT,\n                group,\n            )\n        else:\n            self.send_signal(name, signal.SIGINT, group)\n\n    def terminate(self, name: str, group: bool = False):\n        \"\"\"Terminate the specified named process.\"\"\"\n        self.send_signal(name, signal.SIGTERM, group)\n\n    def kill(self, name: str, group: bool = False):\n        \"\"\"Kill the specified named process.\"\"\"\n        if sys.platform == \"win32\":\n            self.send_signal(name, signal.SIGTERM, group)\n        else:\n            self.send_signal(name, signal.SIGKILL, group)\n\n    def remove(self, name: str, force: bool = False):\n        \"\"\"Remove the specified named process from this manager.\n\n        If the specified process is still running, it will be forcefully killed\n        if `force` is True`, otherwise an exception will be raised.\n\n        Raises:\n            ProcessNotTerminatedError if the specified process is still\n            running and was not forcefully killed.\n        \"\"\"\n        try:\n            process_info = self[name]\n        except KeyError:\n            return\n        if process_info.returncode is None and not force:\n            raise ProcessNotTerminatedError(name)\n        try:\n            self.kill(name)\n        except ProcessLookupError:\n            pass\n        del self[name]\n\n    def cleanup(self, force: bool = False):\n        \"\"\"Remove stale (terminated) processes from this manager.\"\"\"\n        for name in self:\n            try:\n                self.remove(name, force)\n            except ProcessNotTerminatedError:\n                continue\n\n    def follow(\n        self,\n        name: str,\n        encoding: Optional[str] = None,\n        sleep_interval: int = 1,\n    ) -&gt; Generator[str, None, None]:\n        \"\"\"Iterate over lines in redirected output for a process.\n\n        This will block calling thread when waiting for output (until the\n        followed process has exited).\n\n        Arguments:\n            name: Process name.\n            encoding: Text encoding for redirected output. Defaults to\n                `locale.getpreferredencoding()`.\n            sleep_interval: Sleep interval for follow iterations (when waiting\n                for output).\n\n        Note:\n            Yielded strings may not always end in line terminators (all\n            available output will yielded if EOF is reached).\n        \"\"\"\n        output_path = self[name].stdout\n        if output_path is None:\n            return\n        with open(\n            output_path,\n            encoding=encoding or locale.getpreferredencoding(),\n        ) as fobj:\n            while True:\n                offset = fobj.tell()\n                line = fobj.readline()\n                if line:\n                    yield line\n                else:\n                    info = self[name]\n                    if info.returncode is not None:\n                        return\n                    time.sleep(sleep_interval)\n                    fobj.seek(offset)\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager.__init__","title":"<code>__init__(wdir=None)</code>","text":"<p>Construct a ProcessManager</p> <p>Parameters:</p> Name Type Description Default <code>wdir</code> <code>Optional[str]</code> <p>Directory used for storing process information. Defaults to the current working directory.</p> <code>None</code> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def __init__(\n    self,\n    wdir: Optional[str] = None,\n):\n    \"\"\"Construct a ProcessManager\n\n    Arguments:\n        wdir: Directory used for storing process information. Defaults\n            to the current working directory.\n    \"\"\"\n    self.wdir = wdir or os.curdir\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager.cleanup","title":"<code>cleanup(force=False)</code>","text":"<p>Remove stale (terminated) processes from this manager.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def cleanup(self, force: bool = False):\n    \"\"\"Remove stale (terminated) processes from this manager.\"\"\"\n    for name in self:\n        try:\n            self.remove(name, force)\n        except ProcessNotTerminatedError:\n            continue\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager.follow","title":"<code>follow(name, encoding=None, sleep_interval=1)</code>","text":"<p>Iterate over lines in redirected output for a process.</p> <p>This will block calling thread when waiting for output (until the followed process has exited).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Process name.</p> required <code>encoding</code> <code>Optional[str]</code> <p>Text encoding for redirected output. Defaults to <code>locale.getpreferredencoding()</code>.</p> <code>None</code> <code>sleep_interval</code> <code>int</code> <p>Sleep interval for follow iterations (when waiting for output).</p> <code>1</code> Note <p>Yielded strings may not always end in line terminators (all available output will yielded if EOF is reached).</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def follow(\n    self,\n    name: str,\n    encoding: Optional[str] = None,\n    sleep_interval: int = 1,\n) -&gt; Generator[str, None, None]:\n    \"\"\"Iterate over lines in redirected output for a process.\n\n    This will block calling thread when waiting for output (until the\n    followed process has exited).\n\n    Arguments:\n        name: Process name.\n        encoding: Text encoding for redirected output. Defaults to\n            `locale.getpreferredencoding()`.\n        sleep_interval: Sleep interval for follow iterations (when waiting\n            for output).\n\n    Note:\n        Yielded strings may not always end in line terminators (all\n        available output will yielded if EOF is reached).\n    \"\"\"\n    output_path = self[name].stdout\n    if output_path is None:\n        return\n    with open(\n        output_path,\n        encoding=encoding or locale.getpreferredencoding(),\n    ) as fobj:\n        while True:\n            offset = fobj.tell()\n            line = fobj.readline()\n            if line:\n                yield line\n            else:\n                info = self[name]\n                if info.returncode is not None:\n                    return\n                time.sleep(sleep_interval)\n                fobj.seek(offset)\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager.get","title":"<code>get(key, default=None)</code>","text":"<p>Return the specified process.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def get(self, key: str, default=None) -&gt; \"ProcessInfo\":\n    \"\"\"Return the specified process.\"\"\"\n    try:\n        return self[key]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager.interrupt","title":"<code>interrupt(name, group=True)</code>","text":"<p>Send interrupt signal to specified named process</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def interrupt(self, name: str, group: bool = True):\n    \"\"\"Send interrupt signal to specified named process\"\"\"\n    if sys.platform == \"win32\":\n        self.send_signal(\n            name,\n            signal.CTRL_C_EVENT,\n            group,\n        )\n    else:\n        self.send_signal(name, signal.SIGINT, group)\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager.kill","title":"<code>kill(name, group=False)</code>","text":"<p>Kill the specified named process.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def kill(self, name: str, group: bool = False):\n    \"\"\"Kill the specified named process.\"\"\"\n    if sys.platform == \"win32\":\n        self.send_signal(name, signal.SIGTERM, group)\n    else:\n        self.send_signal(name, signal.SIGKILL, group)\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager.processes","title":"<code>processes()</code>","text":"<p>Iterate over managed processes.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def processes(self) -&gt; Generator[Tuple[str, \"ProcessInfo\"], None, None]:\n    \"\"\"Iterate over managed processes.\"\"\"\n    for name in self:\n        try:\n            yield name, self[name]\n        except KeyError:\n            continue\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager.remove","title":"<code>remove(name, force=False)</code>","text":"<p>Remove the specified named process from this manager.</p> <p>If the specified process is still running, it will be forcefully killed if <code>force</code> is True`, otherwise an exception will be raised.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def remove(self, name: str, force: bool = False):\n    \"\"\"Remove the specified named process from this manager.\n\n    If the specified process is still running, it will be forcefully killed\n    if `force` is True`, otherwise an exception will be raised.\n\n    Raises:\n        ProcessNotTerminatedError if the specified process is still\n        running and was not forcefully killed.\n    \"\"\"\n    try:\n        process_info = self[name]\n    except KeyError:\n        return\n    if process_info.returncode is None and not force:\n        raise ProcessNotTerminatedError(name)\n    try:\n        self.kill(name)\n    except ProcessLookupError:\n        pass\n    del self[name]\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager.run_signature","title":"<code>run_signature(args, name=None, task=None, env=None, immutable=False)</code>","text":"<p>Return signature for a task which runs a command in the background.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Union[str, List[str]]</code> <p>Command to run.</p> required <code>name</code> <code>Optional[str]</code> <p>Optional name to use for the spawned process.</p> <code>None</code> <code>task</code> <code>Optional[str]</code> <p>Optional name of Celery task to use for spawning the process. Defaults to 'dvc_task.proc.tasks.run'.</p> <code>None</code> <code>env</code> <code>Optional[Dict[str, str]]</code> <p>Optional environment to be passed into the process.</p> <code>None</code> <code>immutable</code> <code>bool</code> <p>True if the returned Signature should be immutable.</p> <code>False</code> <p>Returns:</p> Type Description <code>Signature</code> <p>Celery signature for the run task.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def run_signature(\n    self,\n    args: Union[str, List[str]],\n    name: Optional[str] = None,\n    task: Optional[str] = None,\n    env: Optional[Dict[str, str]] = None,\n    immutable: bool = False,\n) -&gt; Signature:\n    \"\"\"Return signature for a task which runs a command in the background.\n\n    Arguments:\n        args: Command to run.\n        name: Optional name to use for the spawned process.\n        task: Optional name of Celery task to use for spawning the process.\n            Defaults to 'dvc_task.proc.tasks.run'.\n        env: Optional environment to be passed into the process.\n        immutable: True if the returned Signature should be immutable.\n\n    Returns:\n        Celery signature for the run task.\n    \"\"\"\n    name = name or uuid()\n    task = task or \"dvc_task.proc.tasks.run\"\n    return signature(\n        task,\n        args=(args,),\n        kwargs={\n            \"name\": name,\n            \"wdir\": os.path.join(self.wdir, name),\n            \"env\": env,\n        },\n        immutable=immutable,\n    )\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager.send_signal","title":"<code>send_signal(name, sig, group=False)</code>","text":"<p>Send <code>signal</code> to the specified named process.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def send_signal(self, name: str, sig: int, group: bool = False):  # noqa: C901\n    \"\"\"Send `signal` to the specified named process.\"\"\"\n    try:\n        process_info = self[name]\n    except KeyError as exc:\n        raise ProcessLookupError from exc\n    if sys.platform == \"win32\":\n        if sig not in (\n            signal.SIGTERM,\n            signal.CTRL_C_EVENT,\n            signal.CTRL_BREAK_EVENT,\n        ):\n            raise UnsupportedSignalError(sig)\n\n    def handle_closed_process():\n        logging.warning(\"Process '%s' had already aborted unexpectedly.\", name)\n        process_info.returncode = -1\n        self[name] = process_info\n\n    if process_info.returncode is None:\n        try:\n            if sys.platform != \"win32\" and group:\n                pgid = os.getpgid(process_info.pid)\n                os.killpg(pgid, sig)\n            else:\n                os.kill(process_info.pid, sig)\n        except ProcessLookupError:\n            handle_closed_process()\n            raise\n        except OSError as exc:\n            if sys.platform == \"win32\":\n                if exc.winerror == 87:\n                    handle_closed_process()\n                    raise ProcessLookupError from exc\n            raise\n    else:\n        raise ProcessLookupError\n</code></pre>"},{"location":"reference/dvc_task/proc/manager/#dvc_task.proc.manager.ProcessManager.terminate","title":"<code>terminate(name, group=False)</code>","text":"<p>Terminate the specified named process.</p> Source code in <code>dvc_task/proc/manager.py</code> <pre><code>def terminate(self, name: str, group: bool = False):\n    \"\"\"Terminate the specified named process.\"\"\"\n    self.send_signal(name, signal.SIGTERM, group)\n</code></pre>"},{"location":"reference/dvc_task/proc/process/","title":"Process","text":"<p>Managed process module.</p>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ManagedProcess","title":"<code>ManagedProcess</code>","text":"<p>               Bases: <code>AbstractContextManager</code></p> <p>Class to manage the specified process with redirected output.</p> <p>stdout and stderr will both be redirected to .out. Interactive processes (requiring stdin input) are currently unsupported. Source code in <code>dvc_task/proc/process.py</code> <pre><code>class ManagedProcess(AbstractContextManager):\n    \"\"\"Class to manage the specified process with redirected output.\n\n    stdout and stderr will both be redirected to &lt;name&gt;.out.\n    Interactive processes (requiring stdin input) are currently unsupported.\n    \"\"\"\n\n    def __init__(\n        self,\n        args: Union[str, List[str]],\n        env: Optional[Dict[str, str]] = None,\n        wdir: Optional[str] = None,\n        name: Optional[str] = None,\n    ):\n        \"\"\"Construct a MangedProcess.\n\n        Arguments:\n            args: Command to be run.\n            env: Optional environment variables.\n            wdir: If specified, redirected output files will be placed in\n                `wdir`. Defaults to current working directory.\n            name: Name to use for this process, if not specified a UUID will be\n                generated instead.\n        \"\"\"\n        self.args: List[str] = (\n            shlex.split(args, posix=os.name == \"posix\")\n            if isinstance(args, str)\n            else list(args)\n        )\n        self.env = env\n        self.wdir = wdir\n        self.name = name or uuid()\n        self.returncode: Optional[int] = None\n        self._fd_stack = ExitStack()\n        self._proc: Optional[subprocess.Popen] = None\n\n    def __enter__(self):\n        if self._proc is None:\n            self.run()\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        self.wait()\n\n    def _close_fds(self):\n        with self._fd_stack:\n            pass\n\n    def _make_path(self, path: str) -&gt; str:\n        return os.path.join(self.wdir, path) if self.wdir else path\n\n    @cached_property\n    def stdout_path(self) -&gt; str:\n        \"\"\"Return redirected stdout path.\"\"\"\n        return self._make_path(f\"{self.name}.out\")\n\n    @cached_property\n    def info_path(self) -&gt; str:\n        \"\"\"Return process information file path.\"\"\"\n        return self._make_path(f\"{self.name}.json\")\n\n    @cached_property\n    def pidfile_path(self) -&gt; str:\n        \"\"\"Return process pidfile path.\"\"\"\n        return self._make_path(f\"{self.name}.pid\")\n\n    @property\n    def info(self) -&gt; \"ProcessInfo\":\n        \"\"\"Return process information.\"\"\"\n        return ProcessInfo(\n            pid=self.pid,\n            stdin=None,\n            stdout=self.stdout_path,\n            stderr=None,\n            returncode=self.returncode,\n        )\n\n    @property\n    def pid(self) -&gt; int:\n        \"\"\"Return process PID.\n\n        Raises:\n            ValueError: Process is not running.\n        \"\"\"\n        if self._proc is None:\n            raise ValueError\n        return self._proc.pid\n\n    def _make_wdir(self):\n        if self.wdir:\n            makedirs(self.wdir, exist_ok=True)\n\n    def _dump(self):\n        self._make_wdir()\n        self.info.dump(self.info_path)\n\n        with open(self.pidfile_path, \"w\", encoding=\"utf-8\") as fobj:\n            fobj.write(str(self.pid))\n\n    def run(self):\n        \"\"\"Run this process.\"\"\"\n        self._make_wdir()\n        logger.debug(\n            \"Appending output to '%s'\",\n            self.stdout_path,\n        )\n        stdout = self._fd_stack.enter_context(open(self.stdout_path, \"ab\"))  # noqa: SIM115\n        try:\n            self._proc = subprocess.Popen(  # noqa: S603\n                self.args,\n                stdin=subprocess.DEVNULL,\n                stdout=stdout,\n                stderr=subprocess.STDOUT,\n                close_fds=True,\n                shell=False,\n                env=self.env,\n            )\n            self._dump()\n        except Exception:\n            if self._proc is not None:\n                self._proc.kill()\n            self._close_fds()\n            raise\n\n    def wait(self, timeout: Optional[int] = None) -&gt; Optional[int]:\n        \"\"\"Block until a process started with `run` has completed.\n\n        Raises:\n            TimeoutExpired if `timeout` was set and the process\n            did not terminate after `timeout` seconds.\n        \"\"\"\n        if self.returncode is not None or self._proc is None:\n            return self.returncode\n        try:\n            self._proc.wait(timeout=timeout)\n        except subprocess.TimeoutExpired as exc:\n            raise TimeoutExpired(exc.cmd, exc.timeout) from exc\n        except KeyboardInterrupt:\n            pass\n        self.returncode = self._proc.returncode\n        self._close_fds()\n        self._dump()\n        return self.returncode\n\n    @classmethod\n    def spawn(cls, *args, **kwargs) -&gt; Optional[int]:\n        \"\"\"Spawn a ManagedProcess command in the background.\n\n        Returns: The spawned process PID.\n        \"\"\"\n        proc = _DaemonProcess(\n            target=cls._spawn,\n            args=args,\n            kwargs=kwargs,\n            daemon=True,\n        )\n        proc.start()\n        # Do not terminate the child daemon when the main process exits\n        mp.process._children.discard(proc)  # type: ignore[attr-defined]\n        return proc.pid\n\n    @classmethod\n    def _spawn(cls, *args, **kwargs):\n        with cls(*args, **kwargs):\n            pass\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ManagedProcess.info","title":"<code>info: ProcessInfo</code>  <code>property</code>","text":"<p>Return process information.</p>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ManagedProcess.pid","title":"<code>pid: int</code>  <code>property</code>","text":"<p>Return process PID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Process is not running.</p>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ManagedProcess.__init__","title":"<code>__init__(args, env=None, wdir=None, name=None)</code>","text":"<p>Construct a MangedProcess.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Union[str, List[str]]</code> <p>Command to be run.</p> required <code>env</code> <code>Optional[Dict[str, str]]</code> <p>Optional environment variables.</p> <code>None</code> <code>wdir</code> <code>Optional[str]</code> <p>If specified, redirected output files will be placed in <code>wdir</code>. Defaults to current working directory.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Name to use for this process, if not specified a UUID will be generated instead.</p> <code>None</code> Source code in <code>dvc_task/proc/process.py</code> <pre><code>def __init__(\n    self,\n    args: Union[str, List[str]],\n    env: Optional[Dict[str, str]] = None,\n    wdir: Optional[str] = None,\n    name: Optional[str] = None,\n):\n    \"\"\"Construct a MangedProcess.\n\n    Arguments:\n        args: Command to be run.\n        env: Optional environment variables.\n        wdir: If specified, redirected output files will be placed in\n            `wdir`. Defaults to current working directory.\n        name: Name to use for this process, if not specified a UUID will be\n            generated instead.\n    \"\"\"\n    self.args: List[str] = (\n        shlex.split(args, posix=os.name == \"posix\")\n        if isinstance(args, str)\n        else list(args)\n    )\n    self.env = env\n    self.wdir = wdir\n    self.name = name or uuid()\n    self.returncode: Optional[int] = None\n    self._fd_stack = ExitStack()\n    self._proc: Optional[subprocess.Popen] = None\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ManagedProcess.info_path","title":"<code>info_path()</code>","text":"<p>Return process information file path.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@cached_property\ndef info_path(self) -&gt; str:\n    \"\"\"Return process information file path.\"\"\"\n    return self._make_path(f\"{self.name}.json\")\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ManagedProcess.pidfile_path","title":"<code>pidfile_path()</code>","text":"<p>Return process pidfile path.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@cached_property\ndef pidfile_path(self) -&gt; str:\n    \"\"\"Return process pidfile path.\"\"\"\n    return self._make_path(f\"{self.name}.pid\")\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ManagedProcess.run","title":"<code>run()</code>","text":"<p>Run this process.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>def run(self):\n    \"\"\"Run this process.\"\"\"\n    self._make_wdir()\n    logger.debug(\n        \"Appending output to '%s'\",\n        self.stdout_path,\n    )\n    stdout = self._fd_stack.enter_context(open(self.stdout_path, \"ab\"))  # noqa: SIM115\n    try:\n        self._proc = subprocess.Popen(  # noqa: S603\n            self.args,\n            stdin=subprocess.DEVNULL,\n            stdout=stdout,\n            stderr=subprocess.STDOUT,\n            close_fds=True,\n            shell=False,\n            env=self.env,\n        )\n        self._dump()\n    except Exception:\n        if self._proc is not None:\n            self._proc.kill()\n        self._close_fds()\n        raise\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ManagedProcess.spawn","title":"<code>spawn(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Spawn a ManagedProcess command in the background.</p> <p>Returns: The spawned process PID.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@classmethod\ndef spawn(cls, *args, **kwargs) -&gt; Optional[int]:\n    \"\"\"Spawn a ManagedProcess command in the background.\n\n    Returns: The spawned process PID.\n    \"\"\"\n    proc = _DaemonProcess(\n        target=cls._spawn,\n        args=args,\n        kwargs=kwargs,\n        daemon=True,\n    )\n    proc.start()\n    # Do not terminate the child daemon when the main process exits\n    mp.process._children.discard(proc)  # type: ignore[attr-defined]\n    return proc.pid\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ManagedProcess.stdout_path","title":"<code>stdout_path()</code>","text":"<p>Return redirected stdout path.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@cached_property\ndef stdout_path(self) -&gt; str:\n    \"\"\"Return redirected stdout path.\"\"\"\n    return self._make_path(f\"{self.name}.out\")\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ManagedProcess.wait","title":"<code>wait(timeout=None)</code>","text":"<p>Block until a process started with <code>run</code> has completed.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>def wait(self, timeout: Optional[int] = None) -&gt; Optional[int]:\n    \"\"\"Block until a process started with `run` has completed.\n\n    Raises:\n        TimeoutExpired if `timeout` was set and the process\n        did not terminate after `timeout` seconds.\n    \"\"\"\n    if self.returncode is not None or self._proc is None:\n        return self.returncode\n    try:\n        self._proc.wait(timeout=timeout)\n    except subprocess.TimeoutExpired as exc:\n        raise TimeoutExpired(exc.cmd, exc.timeout) from exc\n    except KeyboardInterrupt:\n        pass\n    self.returncode = self._proc.returncode\n    self._close_fds()\n    self._dump()\n    return self.returncode\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ProcessInfo","title":"<code>ProcessInfo</code>  <code>dataclass</code>","text":"<p>Process information.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@dataclass\nclass ProcessInfo:\n    \"\"\"Process information.\"\"\"\n\n    pid: int\n    stdin: Optional[str]\n    stdout: Optional[str]\n    stderr: Optional[str]\n    returncode: Optional[int]\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"ProcessInfo\":\n        \"\"\"Construct ProcessInfo from the specified dictionary.\"\"\"\n        return cls(**data)\n\n    @classmethod\n    def load(cls, filename: str) -&gt; \"ProcessInfo\":\n        \"\"\"Construct the process information from a file.\"\"\"\n        with open(filename, encoding=\"utf-8\") as fobj:\n            return cls.from_dict(json.load(fobj))\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Return this info as a dictionary.\"\"\"\n        return asdict(self)\n\n    def dump(self, filename: str) -&gt; None:\n        \"\"\"Dump the process information into a file.\"\"\"\n        directory, file = os.path.split(filename)\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\",\n            encoding=\"utf-8\",\n            dir=directory,\n            prefix=f\"{file}.\",\n            suffix=\".tmp\",\n            delete=False,\n        ) as tmp:\n            json.dump(self.asdict(), tmp)\n        os.replace(tmp.name, filename)\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ProcessInfo.asdict","title":"<code>asdict()</code>","text":"<p>Return this info as a dictionary.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Return this info as a dictionary.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ProcessInfo.dump","title":"<code>dump(filename)</code>","text":"<p>Dump the process information into a file.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>def dump(self, filename: str) -&gt; None:\n    \"\"\"Dump the process information into a file.\"\"\"\n    directory, file = os.path.split(filename)\n    with tempfile.NamedTemporaryFile(\n        mode=\"w\",\n        encoding=\"utf-8\",\n        dir=directory,\n        prefix=f\"{file}.\",\n        suffix=\".tmp\",\n        delete=False,\n    ) as tmp:\n        json.dump(self.asdict(), tmp)\n    os.replace(tmp.name, filename)\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ProcessInfo.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Construct ProcessInfo from the specified dictionary.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"ProcessInfo\":\n    \"\"\"Construct ProcessInfo from the specified dictionary.\"\"\"\n    return cls(**data)\n</code></pre>"},{"location":"reference/dvc_task/proc/process/#dvc_task.proc.process.ProcessInfo.load","title":"<code>load(filename)</code>  <code>classmethod</code>","text":"<p>Construct the process information from a file.</p> Source code in <code>dvc_task/proc/process.py</code> <pre><code>@classmethod\ndef load(cls, filename: str) -&gt; \"ProcessInfo\":\n    \"\"\"Construct the process information from a file.\"\"\"\n    with open(filename, encoding=\"utf-8\") as fobj:\n        return cls.from_dict(json.load(fobj))\n</code></pre>"},{"location":"reference/dvc_task/proc/tasks/","title":"Tasks","text":"<p>Celery tasks.</p>"},{"location":"reference/dvc_task/proc/tasks/#dvc_task.proc.tasks.run","title":"<code>run(self, *args, **kwargs)</code>","text":"<p>Run a command inside a celery task.</p> <p>Accepts the same arguments as <code>proc.process.ManagedProcess</code>.</p> Source code in <code>dvc_task/proc/tasks.py</code> <pre><code>@shared_task(bind=True)\ndef run(self, *args: Any, **kwargs: Any) -&gt; Dict[str, Any]:\n    \"\"\"Run a command inside a celery task.\n\n    Accepts the same arguments as `proc.process.ManagedProcess`.\n    \"\"\"\n    with ManagedProcess(*args, **kwargs) as proc:\n        pass\n    return proc.info.asdict()\n</code></pre>"},{"location":"reference/dvc_task/worker/","title":"Worker","text":"<p>DVC Task worker factories.</p>"},{"location":"reference/dvc_task/worker/#dvc_task.worker.TemporaryWorker","title":"<code>TemporaryWorker</code>","text":"<p>Temporary worker that automatically shuts down when queue is empty.</p> Source code in <code>dvc_task/worker/temporary.py</code> <pre><code>class TemporaryWorker:\n    \"\"\"Temporary worker that automatically shuts down when queue is empty.\"\"\"\n\n    def __init__(\n        self,\n        app: Celery,\n        timeout: int = 60,\n        **kwargs,\n    ):\n        \"\"\"Construct a worker.\n\n        Arguments:\n            app: Celery application instance.\n            timeout: Queue timeout in seconds. Worker will be terminated if the\n                queue remains empty after timeout.\n\n        Additional keyword arguments will be passed as celery worker\n        configuration.\n        \"\"\"\n        self.app = app\n        self.timeout = timeout\n        self.config = kwargs\n\n    def ping(self, name: str, timeout: float = 1.0) -&gt; Optional[List[Dict[str, Any]]]:\n        \"\"\"Ping the specified worker.\"\"\"\n        return self._ping(destination=[default_nodename(name)], timeout=timeout)\n\n    def _ping(\n        self, *, destination: Optional[List[str]] = None, timeout: float = 1.0\n    ) -&gt; Optional[List[Dict[str, Any]]]:\n        return self.app.control.ping(destination=destination, timeout=timeout)\n\n    def start(self, name: str, fsapp_clean: bool = False) -&gt; None:\n        \"\"\"Start the worker if it does not already exist.\n\n        Runs the Celery worker main thread in the current process.\n\n        Arguments:\n            name: Celery worker name.\n            fsapp_clean: Automatically cleanup FSApp broker on shutdown. Has no\n                effect unless app is an FSApp instance.\n        \"\"\"\n        if os.name == \"nt\":\n            # see https://github.com/celery/billiard/issues/247\n            os.environ[\"FORKED_BY_MULTIPROCESSING\"] = \"1\"\n\n        if not self.ping(name):\n            monitor = threading.Thread(\n                target=self.monitor,\n                daemon=True,\n                args=(name,),\n            )\n            monitor.start()\n            config = dict(self.config)\n            config[\"hostname\"] = name\n            argv = [\"worker\"]\n            argv.extend(self._parse_config(config))\n            self.app.worker_main(argv=argv)\n            if fsapp_clean and isinstance(self.app, FSApp):  # type: ignore[unreachable]\n                logger.info(\"cleaning up FSApp broker.\")\n                self.app.clean()\n            logger.info(\"done\")\n\n    @staticmethod\n    def _parse_config(config: Mapping[str, Any]) -&gt; List[str]:\n        loglevel = config.get(\"loglevel\", \"info\")\n        argv = [f\"--loglevel={loglevel}\"]\n        for key in (\"hostname\", \"pool\", \"concurrency\", \"prefetch_multiplier\"):\n            value = config.get(key)\n            if value:\n                argv_key = key.replace(\"_\", \"-\")\n                argv.append(f\"--{argv_key}={value}\")\n        for key in (\n            \"without_heartbeat\",\n            \"without_mingle\",\n            \"without_gossip\",\n        ):\n            if config.get(key):\n                argv_key = key.replace(\"_\", \"-\")\n                argv.append(f\"--{argv_key}\")\n        if config.get(\"task_events\"):\n            argv.append(\"-E\")\n        return argv\n\n    def monitor(self, name: str) -&gt; None:\n        \"\"\"Monitor the worker and stop it when the queue is empty.\"\"\"\n        nodename = default_nodename(name)\n\n        def _tasksets(nodes):\n            for taskset in (\n                nodes.active(),\n                nodes.scheduled(),\n                nodes.reserved(),\n            ):\n                if taskset is not None:\n                    yield from taskset.values()\n\n            if isinstance(self.app, FSApp):\n                yield from self.app.iter_queued()\n\n        logger.debug(\"monitor: watching celery worker '%s'\", nodename)\n        while True:\n            time.sleep(self.timeout)\n            nodes = self.app.control.inspect(  # type: ignore[call-arg]\n                destination=[nodename],\n                limit=1,\n            )\n            if nodes is None or not any(tasks for tasks in _tasksets(nodes)):\n                logger.info(\"monitor: shutting down due to empty queue.\")\n                break\n        logger.debug(\"monitor: sending shutdown to '%s'.\", nodename)\n        self.app.control.shutdown()\n        logger.debug(\"monitor: done\")\n</code></pre>"},{"location":"reference/dvc_task/worker/#dvc_task.worker.TemporaryWorker.__init__","title":"<code>__init__(app, timeout=60, **kwargs)</code>","text":"<p>Construct a worker.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Celery</code> <p>Celery application instance.</p> required <code>timeout</code> <code>int</code> <p>Queue timeout in seconds. Worker will be terminated if the queue remains empty after timeout.</p> <code>60</code> <p>Additional keyword arguments will be passed as celery worker configuration.</p> Source code in <code>dvc_task/worker/temporary.py</code> <pre><code>def __init__(\n    self,\n    app: Celery,\n    timeout: int = 60,\n    **kwargs,\n):\n    \"\"\"Construct a worker.\n\n    Arguments:\n        app: Celery application instance.\n        timeout: Queue timeout in seconds. Worker will be terminated if the\n            queue remains empty after timeout.\n\n    Additional keyword arguments will be passed as celery worker\n    configuration.\n    \"\"\"\n    self.app = app\n    self.timeout = timeout\n    self.config = kwargs\n</code></pre>"},{"location":"reference/dvc_task/worker/#dvc_task.worker.TemporaryWorker.monitor","title":"<code>monitor(name)</code>","text":"<p>Monitor the worker and stop it when the queue is empty.</p> Source code in <code>dvc_task/worker/temporary.py</code> <pre><code>def monitor(self, name: str) -&gt; None:\n    \"\"\"Monitor the worker and stop it when the queue is empty.\"\"\"\n    nodename = default_nodename(name)\n\n    def _tasksets(nodes):\n        for taskset in (\n            nodes.active(),\n            nodes.scheduled(),\n            nodes.reserved(),\n        ):\n            if taskset is not None:\n                yield from taskset.values()\n\n        if isinstance(self.app, FSApp):\n            yield from self.app.iter_queued()\n\n    logger.debug(\"monitor: watching celery worker '%s'\", nodename)\n    while True:\n        time.sleep(self.timeout)\n        nodes = self.app.control.inspect(  # type: ignore[call-arg]\n            destination=[nodename],\n            limit=1,\n        )\n        if nodes is None or not any(tasks for tasks in _tasksets(nodes)):\n            logger.info(\"monitor: shutting down due to empty queue.\")\n            break\n    logger.debug(\"monitor: sending shutdown to '%s'.\", nodename)\n    self.app.control.shutdown()\n    logger.debug(\"monitor: done\")\n</code></pre>"},{"location":"reference/dvc_task/worker/#dvc_task.worker.TemporaryWorker.ping","title":"<code>ping(name, timeout=1.0)</code>","text":"<p>Ping the specified worker.</p> Source code in <code>dvc_task/worker/temporary.py</code> <pre><code>def ping(self, name: str, timeout: float = 1.0) -&gt; Optional[List[Dict[str, Any]]]:\n    \"\"\"Ping the specified worker.\"\"\"\n    return self._ping(destination=[default_nodename(name)], timeout=timeout)\n</code></pre>"},{"location":"reference/dvc_task/worker/#dvc_task.worker.TemporaryWorker.start","title":"<code>start(name, fsapp_clean=False)</code>","text":"<p>Start the worker if it does not already exist.</p> <p>Runs the Celery worker main thread in the current process.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Celery worker name.</p> required <code>fsapp_clean</code> <code>bool</code> <p>Automatically cleanup FSApp broker on shutdown. Has no effect unless app is an FSApp instance.</p> <code>False</code> Source code in <code>dvc_task/worker/temporary.py</code> <pre><code>def start(self, name: str, fsapp_clean: bool = False) -&gt; None:\n    \"\"\"Start the worker if it does not already exist.\n\n    Runs the Celery worker main thread in the current process.\n\n    Arguments:\n        name: Celery worker name.\n        fsapp_clean: Automatically cleanup FSApp broker on shutdown. Has no\n            effect unless app is an FSApp instance.\n    \"\"\"\n    if os.name == \"nt\":\n        # see https://github.com/celery/billiard/issues/247\n        os.environ[\"FORKED_BY_MULTIPROCESSING\"] = \"1\"\n\n    if not self.ping(name):\n        monitor = threading.Thread(\n            target=self.monitor,\n            daemon=True,\n            args=(name,),\n        )\n        monitor.start()\n        config = dict(self.config)\n        config[\"hostname\"] = name\n        argv = [\"worker\"]\n        argv.extend(self._parse_config(config))\n        self.app.worker_main(argv=argv)\n        if fsapp_clean and isinstance(self.app, FSApp):  # type: ignore[unreachable]\n            logger.info(\"cleaning up FSApp broker.\")\n            self.app.clean()\n        logger.info(\"done\")\n</code></pre>"},{"location":"reference/dvc_task/worker/temporary/","title":"Temporary","text":"<p>Temporary worker module.</p>"},{"location":"reference/dvc_task/worker/temporary/#dvc_task.worker.temporary.TemporaryWorker","title":"<code>TemporaryWorker</code>","text":"<p>Temporary worker that automatically shuts down when queue is empty.</p> Source code in <code>dvc_task/worker/temporary.py</code> <pre><code>class TemporaryWorker:\n    \"\"\"Temporary worker that automatically shuts down when queue is empty.\"\"\"\n\n    def __init__(\n        self,\n        app: Celery,\n        timeout: int = 60,\n        **kwargs,\n    ):\n        \"\"\"Construct a worker.\n\n        Arguments:\n            app: Celery application instance.\n            timeout: Queue timeout in seconds. Worker will be terminated if the\n                queue remains empty after timeout.\n\n        Additional keyword arguments will be passed as celery worker\n        configuration.\n        \"\"\"\n        self.app = app\n        self.timeout = timeout\n        self.config = kwargs\n\n    def ping(self, name: str, timeout: float = 1.0) -&gt; Optional[List[Dict[str, Any]]]:\n        \"\"\"Ping the specified worker.\"\"\"\n        return self._ping(destination=[default_nodename(name)], timeout=timeout)\n\n    def _ping(\n        self, *, destination: Optional[List[str]] = None, timeout: float = 1.0\n    ) -&gt; Optional[List[Dict[str, Any]]]:\n        return self.app.control.ping(destination=destination, timeout=timeout)\n\n    def start(self, name: str, fsapp_clean: bool = False) -&gt; None:\n        \"\"\"Start the worker if it does not already exist.\n\n        Runs the Celery worker main thread in the current process.\n\n        Arguments:\n            name: Celery worker name.\n            fsapp_clean: Automatically cleanup FSApp broker on shutdown. Has no\n                effect unless app is an FSApp instance.\n        \"\"\"\n        if os.name == \"nt\":\n            # see https://github.com/celery/billiard/issues/247\n            os.environ[\"FORKED_BY_MULTIPROCESSING\"] = \"1\"\n\n        if not self.ping(name):\n            monitor = threading.Thread(\n                target=self.monitor,\n                daemon=True,\n                args=(name,),\n            )\n            monitor.start()\n            config = dict(self.config)\n            config[\"hostname\"] = name\n            argv = [\"worker\"]\n            argv.extend(self._parse_config(config))\n            self.app.worker_main(argv=argv)\n            if fsapp_clean and isinstance(self.app, FSApp):  # type: ignore[unreachable]\n                logger.info(\"cleaning up FSApp broker.\")\n                self.app.clean()\n            logger.info(\"done\")\n\n    @staticmethod\n    def _parse_config(config: Mapping[str, Any]) -&gt; List[str]:\n        loglevel = config.get(\"loglevel\", \"info\")\n        argv = [f\"--loglevel={loglevel}\"]\n        for key in (\"hostname\", \"pool\", \"concurrency\", \"prefetch_multiplier\"):\n            value = config.get(key)\n            if value:\n                argv_key = key.replace(\"_\", \"-\")\n                argv.append(f\"--{argv_key}={value}\")\n        for key in (\n            \"without_heartbeat\",\n            \"without_mingle\",\n            \"without_gossip\",\n        ):\n            if config.get(key):\n                argv_key = key.replace(\"_\", \"-\")\n                argv.append(f\"--{argv_key}\")\n        if config.get(\"task_events\"):\n            argv.append(\"-E\")\n        return argv\n\n    def monitor(self, name: str) -&gt; None:\n        \"\"\"Monitor the worker and stop it when the queue is empty.\"\"\"\n        nodename = default_nodename(name)\n\n        def _tasksets(nodes):\n            for taskset in (\n                nodes.active(),\n                nodes.scheduled(),\n                nodes.reserved(),\n            ):\n                if taskset is not None:\n                    yield from taskset.values()\n\n            if isinstance(self.app, FSApp):\n                yield from self.app.iter_queued()\n\n        logger.debug(\"monitor: watching celery worker '%s'\", nodename)\n        while True:\n            time.sleep(self.timeout)\n            nodes = self.app.control.inspect(  # type: ignore[call-arg]\n                destination=[nodename],\n                limit=1,\n            )\n            if nodes is None or not any(tasks for tasks in _tasksets(nodes)):\n                logger.info(\"monitor: shutting down due to empty queue.\")\n                break\n        logger.debug(\"monitor: sending shutdown to '%s'.\", nodename)\n        self.app.control.shutdown()\n        logger.debug(\"monitor: done\")\n</code></pre>"},{"location":"reference/dvc_task/worker/temporary/#dvc_task.worker.temporary.TemporaryWorker.__init__","title":"<code>__init__(app, timeout=60, **kwargs)</code>","text":"<p>Construct a worker.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Celery</code> <p>Celery application instance.</p> required <code>timeout</code> <code>int</code> <p>Queue timeout in seconds. Worker will be terminated if the queue remains empty after timeout.</p> <code>60</code> <p>Additional keyword arguments will be passed as celery worker configuration.</p> Source code in <code>dvc_task/worker/temporary.py</code> <pre><code>def __init__(\n    self,\n    app: Celery,\n    timeout: int = 60,\n    **kwargs,\n):\n    \"\"\"Construct a worker.\n\n    Arguments:\n        app: Celery application instance.\n        timeout: Queue timeout in seconds. Worker will be terminated if the\n            queue remains empty after timeout.\n\n    Additional keyword arguments will be passed as celery worker\n    configuration.\n    \"\"\"\n    self.app = app\n    self.timeout = timeout\n    self.config = kwargs\n</code></pre>"},{"location":"reference/dvc_task/worker/temporary/#dvc_task.worker.temporary.TemporaryWorker.monitor","title":"<code>monitor(name)</code>","text":"<p>Monitor the worker and stop it when the queue is empty.</p> Source code in <code>dvc_task/worker/temporary.py</code> <pre><code>def monitor(self, name: str) -&gt; None:\n    \"\"\"Monitor the worker and stop it when the queue is empty.\"\"\"\n    nodename = default_nodename(name)\n\n    def _tasksets(nodes):\n        for taskset in (\n            nodes.active(),\n            nodes.scheduled(),\n            nodes.reserved(),\n        ):\n            if taskset is not None:\n                yield from taskset.values()\n\n        if isinstance(self.app, FSApp):\n            yield from self.app.iter_queued()\n\n    logger.debug(\"monitor: watching celery worker '%s'\", nodename)\n    while True:\n        time.sleep(self.timeout)\n        nodes = self.app.control.inspect(  # type: ignore[call-arg]\n            destination=[nodename],\n            limit=1,\n        )\n        if nodes is None or not any(tasks for tasks in _tasksets(nodes)):\n            logger.info(\"monitor: shutting down due to empty queue.\")\n            break\n    logger.debug(\"monitor: sending shutdown to '%s'.\", nodename)\n    self.app.control.shutdown()\n    logger.debug(\"monitor: done\")\n</code></pre>"},{"location":"reference/dvc_task/worker/temporary/#dvc_task.worker.temporary.TemporaryWorker.ping","title":"<code>ping(name, timeout=1.0)</code>","text":"<p>Ping the specified worker.</p> Source code in <code>dvc_task/worker/temporary.py</code> <pre><code>def ping(self, name: str, timeout: float = 1.0) -&gt; Optional[List[Dict[str, Any]]]:\n    \"\"\"Ping the specified worker.\"\"\"\n    return self._ping(destination=[default_nodename(name)], timeout=timeout)\n</code></pre>"},{"location":"reference/dvc_task/worker/temporary/#dvc_task.worker.temporary.TemporaryWorker.start","title":"<code>start(name, fsapp_clean=False)</code>","text":"<p>Start the worker if it does not already exist.</p> <p>Runs the Celery worker main thread in the current process.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Celery worker name.</p> required <code>fsapp_clean</code> <code>bool</code> <p>Automatically cleanup FSApp broker on shutdown. Has no effect unless app is an FSApp instance.</p> <code>False</code> Source code in <code>dvc_task/worker/temporary.py</code> <pre><code>def start(self, name: str, fsapp_clean: bool = False) -&gt; None:\n    \"\"\"Start the worker if it does not already exist.\n\n    Runs the Celery worker main thread in the current process.\n\n    Arguments:\n        name: Celery worker name.\n        fsapp_clean: Automatically cleanup FSApp broker on shutdown. Has no\n            effect unless app is an FSApp instance.\n    \"\"\"\n    if os.name == \"nt\":\n        # see https://github.com/celery/billiard/issues/247\n        os.environ[\"FORKED_BY_MULTIPROCESSING\"] = \"1\"\n\n    if not self.ping(name):\n        monitor = threading.Thread(\n            target=self.monitor,\n            daemon=True,\n            args=(name,),\n        )\n        monitor.start()\n        config = dict(self.config)\n        config[\"hostname\"] = name\n        argv = [\"worker\"]\n        argv.extend(self._parse_config(config))\n        self.app.worker_main(argv=argv)\n        if fsapp_clean and isinstance(self.app, FSApp):  # type: ignore[unreachable]\n            logger.info(\"cleaning up FSApp broker.\")\n            self.app.clean()\n        logger.info(\"done\")\n</code></pre>"}]}